#!/usr/bin/python

"""
# Universal Wayland Desktop Session Manager
Runs selected WM with plugin-extendable tweaks
Manages systemd environment and targets along the way
Inspired by and uses some techniques from:
 https://github.com/xdbob/sway-services
 https://github.com/alebastr/sway-systemd
 https://github.com/swaywm/sway
 https://people.debian.org/~mpitt/systemd.conf-2016-graphical-session.pdf
"""

import os, sys, shlex, argparse, re, subprocess, textwrap, random, time, signal, traceback
from io import StringIO
from urllib import parse as urlparse
from typing import List, Type, IO, Any
from xdg.DesktopEntry import DesktopEntry, which
from xdg import BaseDirectory

stdStream = None | int | IO[Any]


class Varnames:
    "Sets of varnames"
    always_export = {
        "XDG_SESSION_ID",
        "XDG_VTNR",
        "XDG_CURRENT_DESKTOP",
        "XDG_SESSION_DESKTOP",
        "XDG_MENU_PREFIX",
        "PATH",
    }
    never_export = {"PWD", "LS_COLORS", "INVOCATION_ID", "SHLVL", "SHELL"}
    always_unset = {"DISPLAY", "WAYLAND_DISPLAY"}
    always_cleanup = {
        "DISPLAY",
        "WAYLAND_DISPLAY",
        "XDG_SESSION_ID",
        "XDG_VTNR",
        "XDG_CURRENT_DESKTOP",
        "XDG_SESSION_DESKTOP",
        "XDG_MENU_PREFIX",
        "PATH",
        "XCURSOR_THEME",
        "XCURSOR_SIZE",
        "LANG",
    }
    never_cleanup = {"SSH_AGENT_LAUNCHER", "SSH_AUTH_SOCK", "SSH_AGENT_PID"}


class Styles:
    "Terminal control characters for color and style"
    reset = "\033[0m"
    red = "\033[31m"
    green = "\033[32m"
    yellow = "\033[33m"
    pale_yellow = "\033[97m"
    blue = "\033[34m"
    violet = "\033[35m"
    header = "\033[95m"
    bold = "\033[1m"
    under = "\033[4m"
    strike = "\033[9m"
    flash = "\033[5m"


def dedent(data: str) -> str:
    "Applies dedent, lstrips newlines, rstrips except single newline"
    data = textwrap.dedent(data).lstrip("\n")
    return data.rstrip() + "\n" if data.endswith("\n") else data.rstrip()


def wrap_pgs(data: str, maxwidth: int = 0) -> str:
    """
    Splits paragrpaphs by "\n\n", applies wrap of no more than maxwidth to each non-indented one
    If maxwidth == 0, just rejoins each non-indented paragraph into single line
    """
    try:
        width = os.get_terminal_size().columns
    except:
        # default for not being in interactive terminal
        width = 80
    if maxwidth < width:
        width = maxwidth
    paragraphs = data.split("\n\n")
    for idx, paragraph in enumerate(paragraphs):
        # do not touch indented paragraphs
        indented = False
        for line in paragraph.splitlines():
            if line.startswith(" ") or line.startswith("\t"):
                indented = True
        if not indented:
            if width == 0:
                paragraphs[idx] = " ".join(paragraph.splitlines())
            else:
                paragraphs[idx] = "\n".join(textwrap.wrap(paragraph, width=width))
    return "\n\n".join(paragraphs)


def random_hex(length: int = 16) -> str:
    "Returns random hex string of length"
    return "".join([random.choice(list("0123456789abcdef")) for _ in range(length)])


def sane_split(string: str, delimiter: str) -> List[str]:
    "Splits string by delimiter, but returns empty list on empty string"
    if not isinstance(string, str):
        raise TypeError(f'"string" should be a string, got: {type(string)}')
    if not isinstance(delimiter, str):
        raise TypeError(f'"delimiter" should be a string, got: {type(delimiter)}')
    if not delimiter:
        raise ValueError('"delimiter" should not be empty')
    return string.split(delimiter) if string else []


# all print_* functions force flush for synchronized output
def print_normal(*what, **how):
    "Normal print with flush"
    print(*what, **how, flush=True)


def print_ok(*what, **how):
    "Prints in green"
    print(Styles.green, end="", flush=True)
    print(*what, **how, flush=True)
    print(Styles.reset, end="", flush=True)


def print_warning(*what, **how):
    "Prints in yellow"
    print(Styles.yellow, end="", flush=True)
    print(*what, **how, flush=True)
    print(Styles.reset, end="", flush=True)


def print_error(*what, **how):
    "Prints in red to stderr"
    print(Styles.red, end="", file=sys.stderr, flush=True)
    print(*what, **how, file=sys.stderr, flush=True)
    print(Styles.reset, end="", file=sys.stderr, flush=True)


def print_debug(*what, **how):
    "Prints to stderr if DEBUG=N where N > 0"
    if int(os.getenv("DEBUG", "0")) > 0:
        print("DEBUG\n", *what, "\nEND_DEBUG", **how, file=sys.stderr, flush=True)
        print(Styles.reset, end="", file=sys.stderr, flush=True)


def print_style(stls, *what, **how):
    "Prints selected style(s), then args, then resets"
    if isinstance(stls, str):
        stls = [stls]
    for style in stls:
        print(style, end="", flush=True)
    print(*what, **how, flush=True)
    print(Styles.reset, end="", file=sys.stderr, flush=True)


def print_error_or_traceback(exception) -> None:
    "Depending on DEBUG, print nice error or entire exception traceback"
    if int(os.getenv("DEBUG", "0")) > 0:
        print(Styles.red, end="", file=sys.stderr, flush=True)
        traceback.print_exception(exception, file=sys.stderr)
        print(Styles.reset, end="", file=sys.stderr, flush=True)
    else:
        print_error(exception)


def relax_validation(exception):
    "takes pyxdg ValidationError and ignores [stupid] failures"
    ignore_lines = r"ValidationError in file| is not a registered |Invalid key: "
    msgs = str(exception).splitlines()
    return all(re.search(ignore_lines, line) for line in msgs)


def self_name():
    "returns basename of argv[0]"
    return os.path.basename(sys.argv[0])


def self_path():
    "returns path to argv[0] in PATH"
    path = which(self_name())
    if path:
        return path
    print_error(f"{self_name()} is not in PATH or is not executable")
    sys.exit(0)


def load_lib_paths(subpath):
    "get plugins in style of BaseDirectory.load_*_paths"
    out = []
    for path in reversed(
        os.getenv(
            "UWSM_PLUGIN_PREFIX_PATH",
            f"{os.getenv('HOME')}/.local/lib:/usr/local/lib:/usr/lib:/lib",
        ).split(":")
    ):
        file = os.path.join(path, subpath)
        if os.path.isfile(file):
            out.append(file)
    return out


def entry2dict(entry, entry_action=None) -> dict:
    """
    Extracts keys of interest from desktop entry object, returns dict.
    Takes into account "action" for Name, Exec, Icon
    """
    entry_name = os.path.basename(entry.filename)
    out = {
        "Comment": entry.getComment(),
        "Exec": entry.getExec(),
        "GenericName": entry.getGenericName(),
        "Icon": entry.getIcon(),
        "Name": entry.getName(),
        "DesktopNames": entry.get("DesktopNames", list=True),
        "Actions": entry.getActions(),
        "filename": entry.filename,
    }
    print_debug("entry2dict initial", out)
    action_msg = ""
    if entry_action is not None:
        action_msg = f' action "{entry_action}"'
        action_group = f"Desktop Action {entry_action}"
        if entry_action not in entry.getActions() or action_group not in entry.groups():
            raise RuntimeError(
                f'Deskop entry "{entry_name}" does not contain action "{entry_action}"'
            )
        entry.defaultGroup = action_group
        out["Exec"] = entry.getExec()
        out["Name"] = entry.getName()
        # icon can fall back
        if entry.getIcon():
            out["Icon"] = entry.getIcon()
        print_debug("entry2dict action", out)
    if not out["Name"]:
        raise RuntimeError(
            f'Deskop entry "{entry_name}"{action_msg} does not have "Name"'
        )
    if not out["Exec"]:
        raise RuntimeError(
            f'Deskop entry "{entry_name}"{action_msg} does not have "Exec"'
        )
    if not which(shlex.split(out["Exec"])[0]):
        raise RuntimeError(
            f'Deskop entry "{entry_name}"{action_msg} Exec does not contain a reachable executable'
        )
    return out


def get_de(entry_name: str, subpath: str = "wayland-sessions"):
    """
    "which" for desktop entries, takes entry ID or path and hierarchy subpath
    "wayland-sessions", "applications", etc..., default "wayland-sessions"
    returns DesktopEntry object or empty dict
    """

    if not entry_name.endswith(".desktop"):
        print_error(f'Invalid entry name "{entry_name}"')
        return {}

    # if absolute path, use it
    if os.path.isabs(entry_name):
        entry_path = entry_name
        print_debug(f'Entry path is absolute: "{entry_name}"')

    # or find highest priority entry in data hierarchy
    else:
        print_debug(
            f'Entry path is relative: "{entry_name}"\n searching in "{list(BaseDirectory.load_data_paths(subpath))}"'
        )
        entry_path = list(
            BaseDirectory.load_data_paths(
                os.path.normpath(os.path.join(subpath, entry_name))
            )
        )
        if entry_path:
            entry_path = entry_path[0]
        else:
            entry_path = ""

    if not entry_path:
        return {}

    # parse entry
    try:
        entry = DesktopEntry(entry_path)
    except Exception as caught_exception:
        print_error_or_traceback(caught_exception)
        return {}

    print_debug(entry)

    # inaccessible executables or hidden entries
    msgs: list = []
    if entry.getHidden():
        msgs.append("Entry is hidden")
    if not entry.getName:
        msgs.append("Entry is missing Name")
    if (
        (entry.getTryExec() and not entry.findTryExec())
        or not entry.getExec()
        or not which(shlex.split(entry.getExec())[0])  # type: ignore
    ):
        msgs.append("Entry Exec has no reachable executable")
    if msgs:
        print_warning("\n".join(msgs))
        return {}

    return entry


def get_default_de():
    "Gets WM desktop entry ID from wayland-session-default-id file in config hierarchy"
    for cmd_cache_file in BaseDirectory.load_config_paths("wayland-session-default-id"):
        if os.path.isfile(cmd_cache_file):
            try:
                with open(cmd_cache_file, "r", encoding="UTF-8") as cmd_cache_file:
                    for line in cmd_cache_file.readlines():
                        if line.strip():
                            wmid = line.strip()
                            print_ok(f"Got default WM ID: {wmid}")
                            return wmid
            except Exception as caught_exception:
                print_error_or_traceback(caught_exception)
                continue
    return ""


def save_default_de(default):
    "Gets saves WM desktop entry ID from wayland-session-default-id file in config hierarchy"
    if not args.dry_run:
        if not os.path.isdir(BaseDirectory.xdg_config_home):
            os.mkdir(BaseDirectory.xdg_config_home)
        config = os.path.join(
            BaseDirectory.xdg_config_home, "wayland-session-default-id"
        )
        with open(config, "w", encoding="UTF-8") as config:
            config.write(default)
            print_ok(f"Saved default WM ID: {default}")
    else:
        print_ok(f"Would save default WM ID: {default}")


def select_de():
    'Uses whiptail to select among "wayland-sessions" desktop entries'

    if not which("whiptail"):
        raise FileNotFoundError(
            '"whiptail" is not in PATH, "select" and "default" are not supported'
        )

    default: str = get_default_de()
    seen_entries: List[str] = []
    entry_files: List[str] = []
    choices_raw: List[tuple[str]] = []
    choices: List[str] = []

    # find relevant desktop entries as first found paths in data hierarchy
    for ws_dir in BaseDirectory.load_data_paths("wayland-sessions"):
        if os.path.isdir(ws_dir):
            os.chdir(ws_dir)
            for file in os.listdir():
                if os.path.splitext(file)[1] == ".desktop" and file not in seen_entries:
                    seen_entries.append(file)
                    entry_files.append(os.path.join(ws_dir, file))

    entry_files.sort()

    # fill choces list with [Exec, Name], filtered
    for entry_file in entry_files:
        entry = get_de(entry_file)
        if not entry:
            # just skip it
            continue

        entry_filename: str = os.path.basename(entry.filename)
        name: str = entry.getName()
        generic_name: str = entry.getGenericName()
        description: str = " ".join((name, generic_name))
        comment: str = entry.getComment()
        # add a choice
        choices_raw.append((entry_filename, description, comment))

        # also enumerate actions
        for action in entry.getActions():
            print_debug("parsing aciton", action)
            action_group: str = f"Desktop Action {action}"
            if action_group not in entry.groups():
                continue

            # switch to action group
            entry.defaultGroup = action_group
            if (
                not entry.getExec()
                or not which(shlex.split(str(entry.getExec()))[0])
                or not entry.getName()
            ):
                continue

            # action_description: str = f" ╰─▶ {entry.getName()}"
            action_description: str = f" ╰▶ {entry.getName()}"

            # add a choice
            choices_raw.append((f"{entry_filename}:{action}", action_description, ""))

    # find longest description
    description_length: int = 0
    for choice in choices_raw:
        if len(choice[1]) > description_length:
            description_length = len(choice[1])

    # pretty format choices
    col_overhead = 10
    col = os.get_terminal_size().columns
    for choice in choices_raw:
        choices.append(choice[0])
        if choice[2]:
            choices.append(
                f"{choice[1].ljust(description_length)}  {textwrap.shorten(choice[2], col - description_length - col_overhead)}"
            )
        else:
            choices.append(choice[1])

    if not choices:
        raise RuntimeError("No choices found")

    if len(choices) % 2 != 0:
        raise ValueError(
            f"Choices for whiptail are not even ({len(choices)}): {choices}"
        )

    # drop default if not among choices
    if default and default not in choices[::2]:
        default = ""

    # just spit out default if requested and found
    if default and args.wm == "default":
        for choice in choices[::2]:
            if choice == default:
                return choice

    # generate arguments for whiptail exec
    argv = [
        "whiptail",
        "--clear",
        "--backtitle",
        "Universal Wayland Session Manager",
        "--title",
        "Choose compositor",
        # "--nocancel",
        *(("--default-item", default) if default else ""),
        "--menu",
        "",
        "0",
        "0",
        "0",
        "--notags",
        *(choices),
    ]

    # replace whiptail theme with simple default colors
    whiptail_env = dict(os.environ) | {"NEWT_MONO": "true"}
    # run whiptail, capture stderr
    sprc = subprocess.run(
        argv, env=whiptail_env, stderr=subprocess.PIPE, text=True, check=False
    )
    print_debug(sprc)

    return sprc.stderr.strip() if sprc.returncode == 0 and sprc.stderr else ""


def get_unit_path(unit: str, category: str = "runtime", level: str = "user"):
    "Returns tuple: 0) path in category, level dir, 1) unit subpath"
    if os.path.isabs(unit):
        raise RuntimeError("Passed absolute path to get_unit_path")

    unit = os.path.normpath(unit)

    unit_path: str = ""
    if category == "runtime":
        try:
            unit_path = BaseDirectory.get_runtime_dir(strict=True)
        except:
            pass
        if not unit_path:
            print_error("Fatal: empty or undefined XDG_RUNTIME_DIR")
            sys.exit(0)
    else:
        raise RuntimeError(f"category {category} is not supported")

    if level not in ["user"]:
        raise RuntimeError(f"level {level} is not supported")

    unit_dir = os.path.normpath(os.path.join(unit_path, "systemd", level))
    return (unit_dir, unit)


def get_active_wm_id():
    "Finds running wayland-wm@*.service, returns specifier"
    sprc = subprocess.run(
        [
            "systemctl",
            "--user",
            "show",
            "--state=active,activating",
            "--property",
            "Id",
            "--value",
            "wayland-wm@*.service",
        ],
        text=True,
        capture_output=True,
        check=False,
    )
    print_debug(sprc)
    if not sprc.stdout.strip() or sprc.returncode != 0:
        raise RuntimeError(sprc.stdout, sprc.stderr)

    active_id = sprc.stdout.strip()

    sprc = subprocess.run(
        ["systemd-escape", "--unescape", "--instance", active_id],
        text=True,
        capture_output=True,
        check=False,
    )
    print_debug(sprc)
    if not sprc.stdout.strip() or sprc.returncode != 0:
        raise RuntimeError(sprc.stdout, sprc.stderr)

    return sprc.stdout.strip()


def is_active(check_wm_id="", verbose=False):
    "Checks if generic or specific wm_id is in active or activating state, returns bool"
    if check_wm_id:
        check_unit = f"wayland-wm@{check_wm_id}.service"
    else:
        check_unit = "wayland-wm@*.service"
    check_unit_generic = "wayland-wm@*.service"

    sprc = subprocess.run(
        [
            "systemctl",
            "--user",
            "list-units",
            "--state=active,activating",
            "-q",
            "--full",
            "--plain",
            check_unit,
        ],
        text=True,
        capture_output=True,
        check=False,
    )
    print_debug(sprc)

    if sprc.returncode != 0:
        # list-units always returns 0
        raise RuntimeError(sprc.stdout, sprc.stderr, sprc.returncode)

    if sprc.stdout.strip():
        if verbose:
            if sprc.stdout.strip():
                print_normal(sprc.stdout.strip())
            if sprc.stderr.strip():
                print_error(sprc.stderr.strip())
        return True

    if verbose:
        sprc = subprocess.run(
            [
                "systemctl",
                "--user",
                "list-units",
                "--all",
                "-q",
                "--full",
                "--plain",
                check_unit_generic,
            ],
            text=True,
            capture_output=True,
            check=False,
        )
        print_debug(sprc)
        # don't bother for returncode here
        if sprc.stdout.strip():
            print_normal(sprc.stdout.strip())
        if sprc.stderr.strip():
            print_error(sprc.stderr.strip())

    return False


def reload_systemd():
    "Reloads systemd user manager"

    global units_changed

    if args.dry_run:
        print_normal("Will reload systemd user manager")
        units_changed = False
        return True

    print_normal("Reloading systemd user manager")
    sprc = subprocess.run(
        ["systemctl", "--user", "daemon-reload", "-q"],
        text=True,
        capture_output=True,
        check=False,
    )
    print_debug(sprc)
    if sprc.stdout.strip():
        print_normal(sprc.stdout.strip())
    if sprc.stderr.strip():
        print_error(sprc.stderr.strip())

    if sprc.returncode != 0:
        raise RuntimeError(f'"{shlex.join(sprc.args)}" returned {sprc.returncode}')

    units_changed = False
    return True


def update_unit(unit, data):
    """
    Updates unit with data if differs
    Returns change in boolean
    """

    global units_changed

    if not re.search(
        r"[a-zA-Z0-9_:.\\-]+@?\.(service|slice|scope|target|d/[a-zA-Z0-9_:.\\-]+.conf)$",
        unit,
    ):
        raise ValueError(
            f"Trying to update unit with unsupported extension {unit.split('.')[-1]}: {unit}"
        )

    if os.path.isabs(unit):
        unit_dir, unit = ("/", os.path.normpath(unit))
    else:
        if unit.count("/") > 1:
            raise ValueError(
                f"Only single subdir supported for relative unit, got {unit.count('/')} ({unit})"
            )
        unit_dir, unit = get_unit_path(unit)
    unit_path = os.path.join(unit_dir, unit)

    # create subdirs if missing
    check_dir = unit_dir
    if not os.path.isdir(check_dir):
        if not args.dry_run:
            os.mkdir(check_dir)
            print_ok(f'Created dir "{check_dir}/"')
        elif not units_changed:
            print_ok(f'Will create dir "{check_dir}/"')
    for path_element in [d for d in os.path.dirname(unit).split(os.path.sep) if d]:
        check_dir = os.path.join(check_dir, path_element)
        if not os.path.isdir(check_dir):
            if not args.dry_run:
                os.mkdir(check_dir)
                print_ok(f'Created unit subdir "{path_element}/"')
            else:
                print_ok(f'Will create unit subdir "{path_element}/"')

    old_data = ""
    if os.path.isfile(unit_path):
        with open(unit_path, "r", encoding="UTF-8") as unit_file:
            old_data = unit_file.read()

    if data == old_data:
        return False

    if not args.dry_run:
        with open(unit_path, "w", encoding="UTF-8") as unit_file:
            unit_file.write(data)
        print_ok(f'Updated "{unit}"')
    else:
        print_ok(f'Will update "{unit}"')

    units_changed = True
    return True


def remove_unit(unit):
    "Removes unit and subdir if empty"

    global units_changed

    if not re.search(
        r"[a-zA-Z0-9_:.\\-]+@?\.(service|slice|scope|target|d/[a-zA-Z0-9_:.\\-]+.conf)$",
        unit,
    ):
        raise ValueError(
            f"Trying to remove unit with unsupported extension {unit.split('.')[-1]}"
        )

    if os.path.isabs(unit):
        unit_dir, unit = ("/", os.path.normpath(unit))
    else:
        if unit.count("/") > 1:
            raise ValueError(
                f"Only single subdir supported for relative unit, got {unit.count('/')} ({unit})"
            )
        unit_dir, unit = get_unit_path(unit)
    unit_path = os.path.join(unit_dir, unit)

    change = False
    # remove unit file
    if os.path.isfile(unit_path):
        if not args.dry_run:
            os.remove(unit_path)
            print_ok(f"Removed unit {unit}")
        else:
            print_ok(f"Will remove unit {unit}")
        units_changed = True
        change = True

    # deal with subdir
    if not os.path.isabs(unit) and "/" in unit:
        unit_subdir_path = os.path.dirname(unit_path)
        unit_subdir = os.path.dirname(unit)
        unit_filename = os.path.basename(unit_path)
        if os.path.isdir(unit_subdir_path):
            if set(os.listdir(unit_subdir_path)) - {unit_filename}:
                print_warning(f"Subdir {unit_subdir_path} is not empty")
            else:
                if not args.dry_run:
                    os.rmdir(unit_subdir_path)
                    print_ok(f"Removed unit subdir {unit_subdir}")
                else:
                    print_ok(f"Will remove unit subdir {unit_subdir}")

    return change


def generate_units():
    # sourcery skip: assign-if-exp, extract-duplicate-method, remove-redundant-if, split-or-ifs
    "Generates basic unit structure"

    ws_self = self_name()
    ws_self_full = self_path()
    if not ws_self_full:
        print_error(f"{ws_self} is not in PATH. Can not continue!")
        sys.exit(1)

    if args.use_session_slice:
        wayland_wm_slice = "session.slice"
    else:
        wayland_wm_slice = "app.slice"

    global units_changed
    units_changed = False

    # targets
    update_unit(
        "wayland-session-pre@.target",
        dedent(
            f"""
            # injected by {ws_self}, do not edit
            [Unit]
            X-UWSM-ID=GENERIC
            Description=Preparation for session of %I Wayland WM
            Documentation=man:systemd.special(7)
            Requires=basic.target
            StopWhenUnneeded=yes
            BindsTo=graphical-session-pre.target
            Before=graphical-session-pre.target
            PropagatesStopTo=graphical-session-pre.target
            """
        ),
    )
    update_unit(
        "wayland-session@.target",
        dedent(
            f"""
            # injected by {ws_self}, do not edit
            [Unit]
            X-UWSM-ID=GENERIC
            Description=Session of %I Wayland WM
            Documentation=man:systemd.special(7)
            Requires=wayland-session-pre@%i.target graphical-session-pre.target
            After=wayland-session-pre@%i.target graphical-session-pre.target
            StopWhenUnneeded=yes
            BindsTo=graphical-session.target
            Before=graphical-session.target
            PropagatesStopTo=graphical-session.target
            """
        ),
    )
    update_unit(
        "wayland-session-xdg-autostart@.target",
        dedent(
            f"""
            # injected by {ws_self}, do not edit
            [Unit]
            X-UWSM-ID=GENERIC
            Description=XDG Autostart for session of %I Wayland WM
            Documentation=man:systemd.special(7)
            Requires=wayland-session@%i.target graphical-session.target
            After=wayland-session@%i.target graphical-session.target
            StopWhenUnneeded=yes
            BindsTo=xdg-desktop-autostart.target
            Before=xdg-desktop-autostart.target
            PropagatesStopTo=xdg-desktop-autostart.target
            """
        ),
    )

    # services
    update_unit(
        "wayland-wm-env@.service",
        dedent(
            f"""
            # injected by {ws_self}, do not edit
            [Unit]
            X-UWSM-ID=GENERIC
            Description=Environment preloader for %I
            Documentation=man:systemd.service(7)
            BindsTo=wayland-session-pre@%i.target
            Before=wayland-session-pre@%i.target
            StopWhenUnneeded=yes
            [Service]
            Type=oneshot
            RemainAfterExit=yes
            ExecStart={ws_self_full} aux prepare-env "%I"
            ExecStop={ws_self_full} aux cleanup-env
            Restart=no
            SyslogIdentifier={ws_self}_env-preloader
            Slice={wayland_wm_slice}
            """
        ),
    )
    update_unit(
        "wayland-wm@.service",
        dedent(
            f"""
            # injected by {ws_self}, do not edit
            [Unit]
            X-UWSM-ID=GENERIC
            Description=Main service for %I
            Documentation=man:systemd.service(7)
            BindsTo=wayland-session@%i.target
            Before=wayland-session@%i.target
            Requires=wayland-wm-env@%i.service graphical-session-pre.target
            After=wayland-wm-env@%i.service graphical-session-pre.target
            Wants=wayland-session-xdg-autostart@%i.target xdg-desktop-autostart.target
            Before=wayland-session-xdg-autostart@%i.target xdg-desktop-autostart.target app-graphical.slice background-graphical.slice session-graphical.slice
            PropagatesStopTo=app-graphical.slice background-graphical.slice session-graphical.slice
            # dirty fix of xdg-desktop-portal-gtk.service shudown
            PropagatesStopTo=xdg-desktop-portal-gtk.service
            [Service]
            # awaits for 'systemd-notify --ready' from WM child
            Type=notify
            NotifyAccess=all
            ExecStart={ws_self_full} aux exec %I
            Restart=no
            TimeoutStartSec=10
            TimeoutStopSec=10
            SyslogIdentifier={ws_self}_%I
            Slice={wayland_wm_slice}
            """
        ),
    )

    # slices
    update_unit(
        "app-graphical.slice",
        dedent(
            f"""
            # injected by {ws_self}, do not edit
            [Unit]
            X-UWSM-ID=GENERIC
            Description=User Graphical Application Slice
            Documentation=man:systemd.special(7)
            PartOf=graphical-session.target
            After=graphical-session.target
            """
        ),
    )
    update_unit(
        "background-graphical.slice",
        dedent(
            f"""
            # injected by {ws_self}, do not edit
            [Unit]
            X-UWSM-ID=GENERIC
            Description=User Graphical Background Application Slice
            Documentation=man:systemd.special(7)
            PartOf=graphical-session.target
            After=graphical-session.target
            """
        ),
    )
    update_unit(
        "session-graphical.slice",
        dedent(
            f"""
            # injected by {ws_self}, do not edit
            [Unit]
            X-UWSM-ID=GENERIC
            Description=User Graphical Session Application Slice
            Documentation=man:systemd.special(7)
            PartOf=graphical-session.target
            After=graphical-session.target
            """
        ),
    )

    # WM-specific additions from cli or desktop entry via drop-ins
    wm_specific_preloader = f"wayland-wm-env@{wm_id}.service.d/50_custom.conf"
    wm_specific_service = f"wayland-wm@{wm_id}.service.d/50_custom.conf"
    wm_specific_preloader_data = [
        dedent(
            f"""
            # injected by {ws_self}, do not edit
            [Unit]
            X-UWSM-ID={wm_id}
            """
        )
    ]
    wm_specific_service_data = [
        dedent(
            f"""
            # injected by {ws_self}, do not edit
            [Unit]
            X-UWSM-ID={wm_id}
            """
        )
    ]

    # name is given
    if wm_name:
        wm_specific_preloader_data.append(
            dedent(
                f"""
                Description=Environment preloader for {wm_name}
                """
            )
        )

    # name or description is given
    if wm_name or wm_description:
        wm_specific_service_data.append(
            dedent(
                f"""
                Description=Main service for {', '.join((s for s in (wm_name or wm_argv[0], wm_description) if s))}
                """
            )
        )

    # exclusive desktop names were given on command line
    if wm_cli_desktop_names_exclusive:
        prepend: str = f" -eD {':'.join(wm_cli_desktop_names)}"
    # desktop names differ from just executable name
    elif wm_desktop_names != [wm_argv[0]]:
        prepend: str = f" -D {':'.join(wm_desktop_names)}"
    else:
        prepend: str = ""

    # additional args were given on cli
    append: str = f" {shlex.join(wm_cli_args)}" if wm_cli_args else ""

    if prepend or append:
        wm_specific_preloader_data.append(
            dedent(
                f"""
                [Service]
                ExecStart=
                ExecStart={ws_self_full} aux prepare-env{prepend} "%I"{append}
                """
            )
        )

    if append:
        wm_specific_service_data.append(
            dedent(
                f"""
                [Service]
                ExecStart=
                ExecStart={ws_self_full} aux exec "%I"{append}
                """
            )
        )

    if len(wm_specific_preloader_data) > 1:
        # add preloader customization tweak
        update_unit(
            wm_specific_preloader,
            "\n".join(wm_specific_preloader_data),
        )
    else:
        # remove customization tweak
        remove_unit(wm_specific_preloader)

    if len(wm_specific_service_data) > 1:
        # add main service customization tweak
        update_unit(
            wm_specific_service,
            "\n".join(wm_specific_service_data),
        )
    else:
        # remove customization tweak
        remove_unit(wm_specific_service)

    # tweaks
    update_unit(
        "app-@autostart.service.d/slice-tweak.conf",
        dedent(
            f"""
            # injected by {ws_self}, do not edit
            [Unit]
            # make autostart apps stoppable by target
            #StopPropagatedFrom=xdg-desktop-autostart.target
            PartOf=xdg-desktop-autostart.target
            X-UWSM-ID=GENERIC
            [Service]
            # also put them in special graphical app slice
            Slice=app-graphical.slice
            """
        ),
    )
    # this does not work
    # update_unit(
    #     "xdg-desktop-portal-gtk.service.d/part-tweak.conf",
    #     dedent(
    #        f"""
    #        # injected by {ws_self}, do not edit
    #        [Unit]
    #        # make the same thing as -wlr portal to stop correctly
    #        PartOf=graphical-session.target
    #        After=graphical-session.target
    #        ConditionEnvironment=WAYLAND_DISPLAY
    #        X-UWSM-ID=GENERIC
    #        """
    #     )
    # )
    # this breaks xdg-desktop-portal-rewrite-launchers.service
    # update_unit(
    #     "xdg-desktop-portal-.service.d/slice-tweak.conf",
    #     dedent(
    #        f"""
    #        # injected by {ws_self}, do not edit
    #        [Service]
    #        # make xdg-desktop-portal-*.service implementations part of graphical scope
    #        Slice=app-graphical.slice
    #        X-UWSM-ID=GENERIC
    #        """
    #     )
    # )


def remove_units(only=None):
    """
    Removes units by X-UWSM-ID= attribute.
    if wm_id is given as argument, only remove X-UWSM-ID={wm_id}, else remove all.
    """
    if not only:
        only = ""
    check_dir, _ = get_unit_path("")
    sprc = subprocess.run(
        ["grep", "-rlF", f"X-UWSM-ID={only}", check_dir],
        text=True,
        capture_output=True,
        check=False,
    )
    print_debug(sprc)
    if sprc.returncode != 0 or not sprc.stdout.strip():
        return

    files = sprc.stdout.splitlines()
    files = [f.removeprefix(check_dir.rstrip("/") + "/") for f in files]

    for file in sorted(files):
        remove_unit(file)
    return


def parse_args():
    "Parses args, returns tuple with args and a dict of parsers"

    # keep parsers in a dict
    parsers = {}

    # main parser with subcommands
    parsers["main"] = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=wrap_pgs(
            dedent(
                """
                Universal Wayland Session Manager.
                Launches arbitrary wayland WM via a set of systemd user units
                to provide graphical user session with environment management,
                XDG autostart support, scoped application launch helpers,
                clean shutdown.
                """
            )
        ),
        # usage='%(prog)s [-h] action ...',
        epilog=wrap_pgs(
            dedent(
                f"""
                Also see "{self_name()} {{subcommand}} -h" for further info.

                WM should be configured to run this on startup:

                  {self_name()} finalize [[VAR] ANOTHER_VAR]

                (See "{self_name()} finalize --help")

                Startup can be integrated conditionally into shell profile
                (See "{self_name()} check --help")

                During startup at stage of "graphical-session-pre.target" environment is
                sourced from shell profile and from files "wayland-session-env" and
                "wayland-session-env-${{wm}}" in XDG config hierarchy
                (in order of increasing importance). Delta will be exported to systemd and
                dbus activation environments, and cleaned up when services are stopped.

                It is highly recommended to configure your WM to launch apps explicitly scoped
                in special user session slices (app.slice, background.slice, session.slice).
                {self_name()} provides custom nested slices for apps to live in and be
                terminated on session end:

                  app-graphical.slice
                  background-graphical.slice
                  session-graphical.slice

                And helper command to handle all the systemd-run invocations for you:
                (See  "{self_name()} app --help", "man systemd.special", "man systemd-run"

                If app launching is configured as recommended, you can put WM itself in
                session.slice (as recommended by man systemd.special) by setting:

                  UWSM_USE_SESSION_SLICE=true

                This var affects unit generation phase during start, Slice= parameter
                of WM services (best to export it in shell profile).
                """
            )
        ),
    )
    parsers["main_subparsers"] = parsers["main"].add_subparsers(
        title="Action subcommands",
        description=None,
        dest="mode",
        metavar="{subcommand}",
        required=True,
    )

    # wm arguments for potential reuse via parents
    parsers["wm_args"] = argparse.ArgumentParser(add_help=False)
    parsers["wm_args"].add_argument(
        "wm",
        metavar="{wm,wm.desktop[:action]}",
        help='executable or desktop entry (used as WM ID). Special values "select" and "default" in start mode invoke whiptail menu for selecting wayland-sessions desktop entries.',
    )
    parsers["wm_args"].add_argument(
        "args", metavar="...", nargs=argparse.REMAINDER, help="any additional arguments"
    )
    parsers["wm_args"].add_argument(
        "-D",
        metavar="name[:name...]",
        dest="desktop_names",
        default="",
        help="names for XDG_CURRENT_DESKTOP (:-separated)",
    )
    parsers["wm_args"].add_argument(
        "-e",
        dest="desktop_names_exclusive",
        action="store_true",
        help="use desktop names set by -D exclusively, discard other sources",
    )
    parsers["wm_args"].add_argument(
        "-N",
        metavar="Name",
        dest="wm_name",
        default="",
        help="Fancy name for WM (filled from desktop entry by default)",
    )
    parsers["wm_args"].add_argument(
        "-C",
        metavar="Comment",
        dest="wm_comment",
        default="",
        help="Fancy description for WM (filled from desktop entry by default)",
    )

    # start subcommand
    parsers["start"] = parsers["main_subparsers"].add_parser(
        "start",
        help="Start WM",
        description="Generates units for given WM command line or desktop entry and starts WM.",
        parents=[parsers["wm_args"]],
        epilog=dedent(
            """
            During startup at stage of "graphical-session-pre.target" environment is
            sourced from shell profile and from files "wayland-session-env" and
            "wayland-session-env-${wm}" in XDG config hierarchy
            (in order of increasing importance). Delta will be exported to systemd and
            dbus activation environments, and cleaned up when services are stopped.

            """
        ),
    )
    use_session_slice = os.getenv("UWSM_USE_SESSION_SLICE", "false")
    if use_session_slice not in ("true", "false"):
        print_warning(
            f'invalid UWSM_USE_SESSION_SLICE value "{use_session_slice}" ignored, set to "false"'
        )
        use_session_slice = "false"
    parsers["start"].add_argument(
        "-S",
        action="store_true",
        dest="use_session_slice",
        default=use_session_slice == "true",
        help=f"launch WM in session.slice ({'already' if use_session_slice == 'true' else 'can be'} preset by UWSM_USE_SESSION_SLICE env var)",
    )
    parsers["start"].add_argument(
        "-o",
        action="store_true",
        dest="only_generate",
        help="only generate units, but do not start",
    )
    parsers["start"].add_argument(
        "-n", action="store_true", dest="dry_run", help="do not write or start anything"
    )

    # stop subcommand
    parsers["stop"] = parsers["main_subparsers"].add_parser(
        "stop",
        help="Stop WM",
        description="Stops WM and optionally removes generated units.",
        epilog=dedent(
            """
            During shutdown at stage of stopping "graphical-session-pre.target"
            environment is cleaned up from systemd activation environment according
            to a list saved in ${XDG_RUNTIME_DIR}/env_names_for_cleanup_* files.

            """
        ),
    )
    parsers["stop"].add_argument(
        "-r",
        nargs="?",
        metavar="wm,wm.desktop[:action]",
        default=False,
        dest="remove_units",
        help="also remove units (all or only wm-specific)",
    )
    parsers["stop"].add_argument(
        "-n", action="store_true", dest="dry_run", help="do not write or start anything"
    )

    # finalize subcommand
    parsers["finalize"] = parsers["main_subparsers"].add_parser(
        "finalize",
        help="Signal WM startup, export essential and optional variables",
        description="For use inside WM. Sends startup notification to systemd user manager. Exports WAYLAND_DISPLAY, DISPLAY, and any optional variables (mentioned by name as arguments) to systemd user manager. Variables are also added to cleanup list for stop phase.",
    )
    parsers["finalize"].add_argument(
        "env_names",
        metavar="[ENV_NAME [ENV2_NAME ...]]",
        nargs="*",
        help="additional vars to export",
    )

    # app subcommand
    parsers["app"] = parsers["main_subparsers"].add_parser(
        "app",
        help="Scoped app launcher",
        description="Launches application as a scope in specific slice.",
    )
    parsers["app"].add_argument(
        "cmd", metavar="{cmd,app.desktop[:action]}", help="executable or desktop entry"
    )
    parsers["app"].add_argument(
        "args",
        metavar="...",
        nargs=argparse.REMAINDER,
        help="arguments for application",
    )
    parsers["app"].add_argument(
        "-s",
        dest="slice_name",
        metavar="{a,b,s,custom.slice}",
        help=f"{{{Styles.under}a{Styles.reset}pp,{Styles.under}b{Styles.reset}ackground,{Styles.under}s{Styles.reset}ession}}-graphical.slice, or any other. (default: %(default)s)",
        default="a",
    )
    app_unit_type_default = os.getenv("UWSM_APP_UNIT_TYPE", "scope")
    if app_unit_type_default not in ("scope", "service"):
        print_warning(
            f'invalid UWSM_APP_UNIT_TYPE value "{app_unit_type_default}" ignored, set to "scope"'
        )
        app_unit_type_default = "scope"
    parsers["app"].add_argument(
        "-t",
        dest="app_unit_type",
        choices=("scope", "service"),
        default=app_unit_type_default,
        help="type of unit to launch (default: %(default)s, can be preset by UWSM_APP_UNIT_TYPE env var)",
    )
    parsers["app"].add_argument(
        "-a",
        dest="app_name",
        metavar="app_name",
        help="override app name (a substring in unit name)",
        default="",
    )
    parsers["app"].add_argument(
        "-u",
        dest="unit_name",
        metavar="unit_name",
        help="override the whole autogenerated unit name",
        default="",
    )

    # check subcommand
    parsers["check"] = parsers["main_subparsers"].add_parser(
        "check",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        help="Checkers of states",
        description="Performs a check, returns 0 if true, 1 if false.",
        epilog=wrap_pgs(
            dedent(
                f"""
                Use may-start checker to integrate startup into shell profile
                See "{self_name()} check may-start -h"

                """
            )
        ),
    )
    parsers["check_subparsers"] = parsers["check"].add_subparsers(
        title="Subcommands",
        description=None,
        dest="checker",
        metavar="{checker}",
        required=True,
    )
    parsers["is_active"] = parsers["check_subparsers"].add_parser(
        "is-active",
        help="checks for active WM",
        description="Checks for any or specific WM in active or activating state",
    )
    parsers["is_active"].add_argument(
        "wm",
        nargs="?",
        help="specify WM by executable or desktop entry (without arguments)",
    )
    parsers["is_active"].add_argument(
        "-v", action="store_true", dest="verbose", help="show additional info"
    )

    parsers["may_start"] = parsers["check_subparsers"].add_parser(
        "may-start",
        help="checks for start conditions",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="Checks whether it is OK to launch a wayland session.",
        epilog=wrap_pgs(
            dedent(
                f"""
                Conditions:
                  Running from login shell
                  No wayland session is running
                  System is at graphical.target
                  Foreground VT is among allowed (default: 1)

                To integrate startup into shell profile, add:

                  if {self_name()} check may-start
                  then
                  	exec {self_name()} start select
                  fi

                Condition is essential, since {self_name()}'s environment preloader sources
                profile and can cause loops without protection.

                A bit more complex variant with ability to drop to console:

                  if {self_name()} check may-start && \\
                    {self_name()} start -o select
                  then
                  	exec {self_name()} start default
                  fi

                """
            )
        ),
    )
    parsers["may_start"].add_argument(
        "vtnr",
        metavar="[N [N] ...]",
        type=int,
        # default does not work here
        default=[1],
        nargs=argparse.REMAINDER,
        help="VT numbers allowed for start (default: %(default)s)",
    )
    parsers["may_start"].add_argument(
        "-v", action="store_true", dest="verbose", help="show info"
    )

    # aux subcommand
    parsers["aux"] = parsers["main_subparsers"].add_parser(
        "aux",
        help="Auxillary functions",
        description="Can only be called by systemd user manager, used in units Exec*",
    )
    parsers["aux_subparsers"] = parsers["aux"].add_subparsers(
        title="Action subcommands",
        description=None,
        dest="aux_action",
        metavar="{subcommand}",
        required=True,
    )
    parsers["prepare_env"] = parsers["aux_subparsers"].add_parser(
        "prepare-env",
        help="prepares environment (for use in wayland-wm-env@.service in wayland-session-pre@.target)",
        description="Used in ExecStart of wayland-wm-env@.service.",
        parents=[parsers["wm_args"]],
    )
    parsers["cleanup_env"] = parsers["aux_subparsers"].add_parser(
        "cleanup-env",
        help="Cleans up environment (for use in wayland-wm-env@.service in wayland-session-pre@.target)",
        description="Used in ExecStop of wayland-wm-env@.service.",
    )
    parsers["exec"] = parsers["aux_subparsers"].add_parser(
        "exec",
        help="Executes binary with arguments or desktop entry (for use in wayland-wm@.service in wayland-session@.target)",
        description="Used in ExecStart of wayland-wm@.service.",
    )
    parsers["exec"].add_argument(
        "wm",
        metavar="{wm,wm.desktop[:action]}",
        help="executable or desktop entry (used as WM ID)",
    )
    parsers["exec"].add_argument(
        "args", metavar="...", nargs=argparse.REMAINDER, help="any additional arguments"
    )

    args = parsers["main"].parse_args()
    return (args, parsers)


def finalize(additional_vars=None):
    "Optionally takes list of additional vars. Exports defined subset of WAYLAND_DISPLAY, DISPLAY, additional vars."

    if additional_vars is None:
        additional_vars = []

    if not os.getenv("WAYLAND_DISPLAY", ""):
        print_error(
            "WAYLAND_DISPLAY is not defined or empty. Are we being run by a wayland compositor or not?"
        )
        sys.exit(1)
    export_vars = []
    for var in ["WAYLAND_DISPLAY", "DISPLAY"] + sorted(additional_vars):
        if os.getenv(var, None) is not None and var not in export_vars:
            export_vars.append(var)

    wm_id = get_active_wm_id()

    # append vars to cleanup file
    cleanup_file = os.path.join(
        BaseDirectory.get_runtime_dir(strict=True), f"env_names_for_cleanup_{wm_id}"
    )
    if os.path.isfile(cleanup_file):
        with open(cleanup_file, "r", encoding="UTF-8") as open_cleanup_file:
            current_cleanup_varnames = {
                l.strip() for l in open_cleanup_file.readlines() if l.strip()
            }
    else:
        print_error(f'"{cleanup_file}" does not exist\nAssuming env preloader failed')
        sys.exit(1)
    with open(cleanup_file, "w", encoding="UTF-8") as open_cleanup_file:
        open_cleanup_file.write(
            "\n".join(sorted(current_cleanup_varnames | set(export_vars)))
        )

    # export vars
    print_normal(
        "Exporting variables to systemd_user_manager:\n  " + "\n  ".join(export_vars)
    )
    sprc = subprocess.run(
        ["dbus-update-activation-environment", "--systemd", *(export_vars)],
        text=True,
        capture_output=True,
        check=False,
    )
    print_debug(sprc)
    if sprc.stdout.strip():
        print_normal(sprc.stdout.strip())
    if sprc.stderr.strip():
        print_error(sprc.stderr.strip())
    if sprc.returncode != 0:
        sys.exit(1)

    sprc = subprocess.run(
        ["systemctl", "--user", "import-environment", *(export_vars)],
        text=True,
        capture_output=True,
        check=False,
    )
    print_debug(sprc)
    if sprc.stdout.strip():
        print_normal(sprc.stdout.strip())
    if sprc.stderr.strip():
        print_error(sprc.stderr.strip())
    if sprc.returncode != 0:
        sys.exit(1)

    # if no prior failures, exec systemd-notify
    print_normal(f"Finalizing startup of {wm_id}")
    os.execlp("systemd-notify", "systemd-notify", "--ready")

    # we should not be here
    print_error("Something went wrong")
    sys.exit(1)


def get_systemd_varnames():
    "Returns set of env names from systemd user manager"
    sprc = subprocess.run(
        ["systemctl", "--user", "show-environment"],
        text=True,
        capture_output=True,
        check=False,
    )
    print_debug(sprc)
    if sprc.returncode != 0:
        raise RuntimeError(f'"{shlex.join(sprc.args)}" returned {sprc.returncode}')
    # Systemctl always returns one value per line
    # Either var=value or var=$'complex\nescaped\nvalue'.
    # Seems to be safe to use .splitlines().
    # If values are needed, they can be rendered
    return {v.split("=")[0] for v in sprc.stdout.splitlines()}


def get_fg_vt(verbose: bool = False):
    "Returns number of foreground VT or None"
    sprc = subprocess.run(["fgconsole"], text=True, capture_output=True, check=False)
    print_debug(sprc)

    if sprc.stderr.strip():
        if verbose:
            print_error(f"fgconsole error:\n{sprc.stderr.strip()}")

    if sprc.returncode != 0:
        if verbose:
            print_error(
                f"Could not determine foreground VT, fgconsole returned {sprc.returncode}"
            )
        return None

    fgvt = sprc.stdout.strip()

    if not fgvt or not fgvt.isnumeric():
        if verbose:
            print_error(
                f'Could not determine foreground VT, fgconsole output: "{sprc.stdout.strip()}"'
            )
        return None

    fgvt = int(fgvt)
    return fgvt


def get_session_by_vt(v_term: int, verbose: bool = False):
    "Takes VT number, returns associated XDG session ID or None"

    # get session list
    sprc = subprocess.run(
        ["loginctl", "list-sessions", "--no-legend", "--no-pager"],
        text=True,
        capture_output=True,
        check=False,
    )
    print_debug(sprc)
    if sprc.returncode != 0:
        if verbose:
            print_error(f'"{shlex.join(sprc.args)}" returned {sprc.returncode}')
        return None
    if sprc.stderr.strip():
        print_error(sprc.stderr.strip())

    # iterate over sessions
    for line in sprc.stdout.splitlines():
        # id is the first number in line, can be space-padded, so strip
        session_id = line.strip().split(" ")[0]
        if not session_id.isnumeric():
            if verbose:
                print_error(f'Encountered malformed session ID "{session_id}"')
            continue

        # get session user and VTNr
        sprc2 = subprocess.run(
            [
                "loginctl",
                "show-session",
                session_id,
                "--property",
                "Name",
                "--property",
                "VTNr",
            ],
            text=True,
            capture_output=True,
            check=False,
        )
        print_debug(sprc2)
        if sprc2.returncode != 0:
            if verbose:
                print_error(f'"{shlex.join(sprc2.args)}" returned {sprc2.returncode}')
            continue
        if sprc2.stderr.strip():
            print_error(sprc.stderr.strip())

        # order is not governed by arguments, seems to be alphabetic, but sort to be sure
        props = sorted(sprc2.stdout.splitlines())
        if len(props) != 2:
            if verbose:
                print_error(
                    f'{shlex.join(sprc2.args)}" printed unparseable properties:\n{sprc2.stdout.strip()}'
                )
            continue
        user: str = props[0].split("=")[1]
        vtnr: str = props[1].split("=")[1]

        if not user:
            if verbose:
                print_error(f'{shlex.join(sprc2.args)}" printed empty user')
            continue
        if not vtnr.isnumeric():
            if verbose:
                print_error(
                    f'{shlex.join(sprc2.args)}" printed malformed vtnr: "{vtnr}"'
                )
            continue

        if int(vtnr) == v_term and user == os.getlogin():
            session_id = int(session_id)
            return session_id

    return None


def prepare_env_gen_sh(random_mark):
    """
    Takes a known random string, returns string with shell code for sourcing env.
    Code echoes given string to mark the beginning of "env -0" output
    """

    # vars for use in plugins
    shell_definitions = dedent(
        f"""
        __WM_ID__={shlex.quote(wm_id)}
        __WM_BIN_ID__={shlex.quote(wm_bin_id)}
        __WM_DESKTOP_NAMES__={shlex.quote(':'.join(wm_desktop_names))}
        __WM_FIRST_DESKTOP_NAME__={shlex.quote(wm_desktop_names[0])}
        __WM_DESKTOP_NAMES_EXCLUSIVE__={'true' if wm_cli_desktop_names_exclusive else 'false'}
        """
    )

    # bake plugin load into shell
    shell_plugins = load_lib_paths(f"wayland-session-plugins/{wm_bin_id}.sh.in")
    shell_plugins_load = []
    for plugin in shell_plugins:
        shell_plugins_load.append(
            dedent(
                f"""
                echo "Loading plugin \\"{plugin}\\""
                . "{plugin}"
                """
            )
        )
    shell_plugins_load = "\n".join(shell_plugins_load)

    # static part
    shell_main_body = dedent(
        """
        load_config_env() {
        	#### iterate config dirs in increasing importance and source additional env from relative path in $1
        	__ALL_XDG_CONFIG_DIRS_REV__=''
        	__CONFIG_DIR__=''
        	OIFS="$IFS"
        	IFS=":"
        	for __CONFIG_DIR__ in ${XDG_CONFIG_HOME}:${XDG_CONFIG_DIRS}
        	do
        		IFS="$OIFS"
        		# fill list in reverse order
        		if [ -n "${__CONFIG_DIR__}" ]
        		then
        			__ALL_XDG_CONFIG_DIRS_REV__="${__ALL_XDG_CONFIG_DIRS_REV__}${__ALL_XDG_CONFIG_DIRS_REV__:+:}${__CONFIG_DIR__}"
        		fi
        	done
        	IFS=":"
        	for __CONFIG_DIR__ in ${__ALL_XDG_CONFIG_DIRS_REV__}
        	do
        		IFS="$OIFS"
        		if [ -r "${__CONFIG_DIR__}/${1}" ]
        		then
        			echo "Loading environment from ${__CONFIG_DIR__}/${1}"
        			#set -a
        			. "${__CONFIG_DIR__}/${1}"
        			#set +a
        		fi
        	done
        	IFS="$OIFS"
        	unset __CONFIG_DIR__
        	unset __ALL_XDG_CONFIG_DIRS_REV__
        	return 0
        }

        load_common_env() {
        	load_config_env "wayland-session-env"
        }

        load_wm_env() {
        	load_config_env "wayland-session-env-${__WM_BIN_ID__}"
        }

        #### Basic environment
        [ -f /etc/profile ] && . /etc/profile
        [ -f "${HOME}/.profile" ] && . "${HOME}/.profile"
        export PATH
        export XDG_CONFIG_DIRS="${XDG_CONFIG_DIRS:-/etc/xdg}"
        export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-${HOME}/.config}"
        export XDG_DATA_DIRS="${XDG_DATA_DIRS:-/usr/local/share:/usr/share}"
        export XDG_DATA_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}"
        export XDG_CACHE_HOME="${XDG_CACHE_HOME:-${HOME}/.cache}"
        export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/$(id -u)}"

        export XDG_CURRENT_DESKTOP="${__WM_DESKTOP_NAMES__}"
        export XDG_SESSION_DESKTOP="${__WM_FIRST_DESKTOP_NAME__}"
        export XDG_MENU_PREFIX="${__WM_FIRST_DESKTOP_NAME__}-"

        #### apply quirks
        if type "quirks_${__WM_BIN_ID__}" >/dev/null
        then
                echo "Applying quirks for ${__WM_BIN_ID__}"
                "quirks_${__WM_BIN_ID__}" || return $?
        fi

        load_common_env || return $?

        if type "load_wm_env_${__WM_BIN_ID__}" >/dev/null
        then
                echo "Loading ENV for ${__WM_BIN_ID__}"
                "load_wm_env_${__WM_BIN_ID__}" || return $?
        else
                load_wm_env || return $?
                true
        fi
        """
    )

    # pass env after the mark
    shell_print_env = dedent(
        f"""
        printf "%s" "{random_mark}"
        env -0
        """
    )

    shell_full = "\n".join(
        [shell_definitions, shell_plugins_load, shell_main_body, shell_print_env]
    )

    print_debug(shell_full)

    return shell_full


def filter_varnames(data):
    """
    Filters variable names (some environments can introduce garbage).
    Accepts dicts of env or lists, tuples, sets of names. Returns only valid.
    """
    if not isinstance(data, (dict, set, list, tuple)):
        raise TypeError(f"Received {type(data)}")
    varname_regexp = r"^([a-zA-Z_][a-zA-Z0-9_]+|[a-zA-Z][a-zA-Z0-9_]*)$"

    if isinstance(data, dict):
        for var in list(data.keys()):
            if not re.search(varname_regexp, var):
                print_warning(f'Encountered illegal var "{var}"')
                data.pop(var)
        return data

    if isinstance(data, (set, list, tuple)):
        new_data = []
        for var in data:
            if not re.search(varname_regexp, var):
                print_warning(f'Encountered illegal var "{var}"')
            else:
                new_data.append(var)
        if isinstance(data, set):
            return set(new_data)
        if isinstance(data, tuple):
            return tuple(new_data)
        if isinstance(data, list):
            return new_data

    raise RuntimeError(f'Should not get here with data "{data}" ({type(data)})')


def prepare_env():
    """
    Runs shell code to source native shell env fragments,
    Captures difference in env before and after,
    Filters it and exports to systemd user manager,
    Saves list for later cleanup.
    """

    print_normal(f"Preparing environment for {wm_name or wm_argv[0]}...")

    # get current ENV
    env_pre = filter_varnames(dict(os.environ))

    # override XDG_VTNR and XDG_SESSION_ID right away, they are in Varnames.always_export
    v_term = get_fg_vt()
    if v_term is None:
        raise RuntimeError("Could not determine foreground VT")
    session_id = get_session_by_vt(v_term)
    if session_id is None:
        raise RuntimeError("Could not determine session of foreground VT")
    env_pre.update({"XDG_VTNR": str(v_term), "XDG_SESSION_ID": str(session_id)})

    # Run shell code to prepare env and print results
    random_mark = f"MARK_{random_hex(16)}_MARK"
    shell_code = prepare_env_gen_sh(random_mark)

    sprc = subprocess.run(
        ["sh", "-"],
        text=True,
        input=shell_code,
        capture_output=True,
        env=env_pre,
        check=False,
    )
    print_debug(sprc)

    # cut everything before and including random mark, also the last \0
    # treat stdout before the mark as messages
    mark_position = sprc.stdout.find(random_mark)
    if mark_position < 0:
        # print whole stdout
        if sprc.stdout.strip():
            print_normal(sprc.stdout.strip())
        # print any stderr as errors
        if sprc.stderr.strip():
            print_error(sprc.stderr.strip())
        raise RuntimeError(
            f'Env output mark "{random_mark}" not found in shell output!'
        )

    stdout_msg = sprc.stdout[0:mark_position]
    stdout = sprc.stdout[mark_position + len(random_mark) :].rstrip("\0")

    # print stdout if any
    if stdout_msg.strip():
        print_normal(stdout_msg.strip())
    # print any stderr as errors
    if sprc.stderr.strip():
        print_error(sprc.stderr.strip())

    if sprc.returncode != 0:
        raise RuntimeError(f"Shell returned {returncode}!")

    # parse env
    env_post = {}
    for env in stdout.split("\0"):
        env = env.split("=", maxsplit=1)
        if len(env) == 2:
            env_post.update({env[0]: env[1]})
        else:
            print_error(f"No value: {env}")
    env_post = filter_varnames(env_post)

    # get systemd user manager ENV names
    systemd_varnames = get_systemd_varnames()

    ## Dict of vars to put into systemd user manager
    # raw difference dict between env_post and env_pre
    set_env = dict(set(env_post.items()) - set(env_pre.items()))

    print_debug("env_pre", env_pre)
    print_debug("env_post", env_post)
    print_debug("set_env", set_env)

    # add "always_export" vars from env_post to set_env
    for var in sorted(
        Varnames.always_export - Varnames.never_export - Varnames.always_unset
    ):
        if var in env_post:
            print_debug(f'Forcing export of {var}="{env_post[var]}"')
            set_env.update({var: env_post[var]})

    # remove "never_export" and "always_unset" vars from set_env
    for var in Varnames.never_export | Varnames.always_unset:
        if var in set_env:
            print_debug(f"Excluding export of {var}")
            set_env.pop(var)

    # Set of varnames to remove from systemd user manager
    # raw reverse difference
    unset_varnames = set(env_pre.keys()) - set(env_post.keys())
    # add "always_unset" vars
    unset_varnames = unset_varnames | set(Varnames.always_unset)
    # leave only those that are defined in systemd user manager
    unset_varnames = unset_varnames & systemd_varnames

    # Set of vars to remove from systemd user manager on shutdown
    cleanup_varnames = (
        set(set_env.keys()) | Varnames.always_cleanup - Varnames.never_cleanup
    )

    # write cleanup file
    # first get exitsing vars if cleanup file already exists
    cleanup_file = os.path.join(
        BaseDirectory.get_runtime_dir(strict=True), f"env_names_for_cleanup_{wm_id}"
    )
    if os.path.isfile(cleanup_file):
        with open(cleanup_file, "r", encoding="UTF-8") as open_cleanup_file:
            current_cleanup_varnames = {
                l.strip() for l in open_cleanup_file.readlines() if l.strip()
            }
    else:
        current_cleanup_varnames = set()
    # write cleanup file
    with open(cleanup_file, "w", encoding="UTF-8") as open_cleanup_file:
        open_cleanup_file.write(
            "\n".join(sorted(current_cleanup_varnames | cleanup_varnames))
        )

    # print message about env export
    set_env_msg = "Exporting variables to systemd user manager:\n  " + "\n  ".join(
        sorted(set_env.keys())
    )
    print_normal(set_env_msg)
    # export env by running systemctl in set_env environment
    sprc = subprocess.run(
        ["systemctl", "--user", "import-environment"] + sorted(set_env.keys()),
        env=env_post,
        text=True,
        capture_output=True,
        check=False,
    )
    print_debug(sprc)
    if sprc.stdout.strip():
        print_normal(sprc.stdout.strip())
    if sprc.stderr.strip():
        print_error(sprc.stderr.strip())
    if sprc.returncode != 0:
        raise RuntimeError(f'"{shlex.join(sprc.args)}" returned {sprc.returncode}')

    # export env by running dbus-update-activation-environment in set_env environment
    sprc = subprocess.run(
        ["dbus-update-activation-environment", "--systemd"] + sorted(set_env.keys()),
        env=env_post,
        text=True,
        capture_output=True,
        check=False,
    )
    print_debug(sprc)
    if sprc.stdout.strip():
        print_normal(sprc.stdout.strip())
    if sprc.stderr.strip():
        print_error(sprc.stderr.strip())
    if sprc.returncode != 0:
        raise RuntimeError(f'"{shlex.join(sprc.args)}" returned {sprc.returncode}')

    if unset_varnames:
        # print message about env unset
        unset_varnames_msg = (
            "Unsetting variables from systemd user manager:\n  "
            + "\n  ".join(sorted(unset_varnames))
        )
        print_normal(unset_varnames_msg)

        # unset env by running systemctl
        sprc = subprocess.run(
            ["systemctl", "--user", "unset-environment"] + sorted(unset_varnames),
            text=True,
            capture_output=True,
            check=False,
        )
        print_debug(sprc)
        if sprc.stdout.strip():
            print_normal(sprc.stdout.strip())
        if sprc.stderr.strip():
            print_error(sprc.stderr.strip())
        if sprc.returncode != 0:
            raise RuntimeError(f'"{shlex.join(sprc.args)}" returned {sprc.returncode}')

    # print message about future env cleanup
    cleanup_varnames_msg = (
        "Variables marked for cleanup from systemd user manager on stop:\n  "
        + "\n  ".join(sorted(cleanup_varnames))
    )
    print_normal(cleanup_varnames_msg)


def cleanup_env():
    """
    takes var names from "${XDG_RUNTIME_DIR}/env_names_for_cleanup_*"
    union Varnames.always_cleanup,
    difference Varnames.never_cleanup,
    intersect actual systemd user manager varnames,
    and remove them from systemd user manager.
    Remove found cleanup files
    """

    print_normal("Cleaning up...")

    cleanup_file_dir = BaseDirectory.get_runtime_dir(strict=True)
    cleanup_files = []
    for cleanup_file in os.listdir(cleanup_file_dir):
        if not cleanup_file.startswith("env_names_for_cleanup_"):
            continue
        cleanup_file = os.path.join(cleanup_file_dir, cleanup_file)
        if os.path.isfile(cleanup_file):
            print_normal(f'Found cleanup_file "{os.path.basename(cleanup_file)}"')
            cleanup_files.append(cleanup_file)

    if not cleanup_files:
        print_warning("No cleanup files found")
        sys.exit(0)

    current_cleanup_varnames = set()
    for cleanup_file in cleanup_files:
        if os.path.isfile(cleanup_file):
            with open(cleanup_file, "r", encoding="UTF-8") as open_cleanup_file:
                current_cleanup_varnames = current_cleanup_varnames | {
                    l.strip() for l in open_cleanup_file.readlines() if l.strip()
                }

    systemd_varnames = get_systemd_varnames()

    cleanup_varnames = (
        current_cleanup_varnames
        | Varnames.always_cleanup - Varnames.never_cleanup & systemd_varnames
    )

    if cleanup_varnames:
        cleanup_varnames_msg = (
            "Cleaning up variables from systemd user manager:\n  "
            + "\n  ".join(sorted(cleanup_varnames))
        )
        print_normal(cleanup_varnames_msg)

        # nullify vars in dbus environment
        sprc = subprocess.run(
            ["dbus-update-activation-environment", "--systemd"]
            + sorted([f"{n}=" for n in cleanup_varnames]),
            text=True,
            capture_output=True,
            check=False,
        )
        print_debug(sprc)
        if sprc.stdout.strip():
            print_normal(sprc.stdout.strip())
        if sprc.stderr.strip():
            print_error(sprc.stderr.strip())
        if sprc.returncode != 0:
            # just print error here
            print_error(f'"{shlex.join(sprc.args)}" returned {returncode}')

        sprc = subprocess.run(
            ["systemctl", "--user", "unset-environment"] + sorted(cleanup_varnames),
            text=True,
            capture_output=True,
            check=False,
        )
        print_debug(sprc)
        if sprc.stdout.strip():
            print_normal(sprc.stdout.strip())
        if sprc.stderr.strip():
            print_error(sprc.stderr.strip())
        if sprc.returncode != 0:
            raise RuntimeError(f'"{shlex.join(sprc.args)}" returned {returncode}')

    for cleanup_file in cleanup_files:
        os.remove(cleanup_file)
        print_ok(f'Removed "{os.path.basename(cleanup_file)}"')


def path2url(arg):
    "If argument is not an url, convert to url"
    if urlparse.urlparse(arg).scheme:
        return arg
    return f"file:{urlparse.quote(arg)}"


def gen_entry_args(entry, args, entry_action=None):
    """
    Takes DesktopEntry object and additional args, returns rendered argv as (cmd, args).
    "args" can be a list of args or a list of lists of args if multiple instances of cmd
    are required.
    """

    # Parsing of fields:
    # %f single path, run multiple instances per path
    # %F multiple paths as args
    # %u single url, convert non-url to 'file:' url, run multiple instances per url
    # %U multiple urls as args, convert non-url to 'file:' url
    # %c translated Name=
    # %k entry path
    # %i --icon getIcon() if getIcon()

    entry_dict = entry2dict(entry, entry_action=entry_action)

    entry_argv = shlex.split(entry_dict["Exec"])

    entry_cmd, entry_args = entry_argv[0], entry_argv[1:]
    print_debug("entry_cmd, entry_args pre:", entry_cmd, entry_args)

    ## search for fields to expand or pop
    # expansion counter
    expand = 0
    # %[fFuU] recorder
    encountered_fu = ""

    for idx, entry_arg in enumerate(entry_args.copy()):
        print_debug(f"parsing argument {idx + 1}: {entry_arg}")
        if entry_arg == "%f":
            if encountered_fu:
                raise RuntimeError(
                    f'Desktop entry has conflicting args: "{encountered_fu}", "{entry_arg}"'
                )
            encountered_fu = entry_arg

            if len(args) <= 1:
                # pop field arg
                entry_args.pop(idx + expand)
                expand -= 1
                print_debug(f"popped {entry_arg}, expand: {expand}, {entry_args}")

                if args:
                    # replace field with single argument
                    entry_args.insert(idx + expand, args[0])
                    expand += 1
                    print_debug(f"added {args[0]}, expand: {expand}, {entry_args}")

            else:
                # leave field arg for later iterative replacement
                print_debug(f"ignored {entry_arg}, expand: {expand}, {entry_args}")

        elif entry_arg == "%F":
            if encountered_fu:
                raise RuntimeError(
                    f'Desktop entry has conflicting args: "{encountered_fu}", "{entry_arg}"'
                )
            encountered_fu = entry_arg

            # pop field arg
            entry_args.pop(idx + expand)
            expand -= 1
            print_debug(f"popped {entry_arg}, expand: {expand}, {entry_args}")

            # replace with arguments
            for arg in args:
                entry_args.insert(idx + expand, arg)
                expand += 1
                print_debug(f"added {arg}, expand: {expand}, {entry_args}")

        elif entry_arg == "%u":
            if encountered_fu:
                raise RuntimeError(
                    f'Desktop entry has conflicting args: "{encountered_fu}", "{entry_arg}"'
                )
            encountered_fu = entry_arg

            if len(args) <= 1:
                # pop field arg
                entry_args.pop(idx + expand)
                expand -= 1
                print_debug(f"popped {entry_arg}, expand: {expand}, {entry_args}")

                if args:
                    # replace field with single argument
                    # convert to url, assume file
                    arg = path2url(args[0])
                    entry_args.insert(idx + expand, arg)
                    expand += 1
                    print_debug(f"added {arg}, expand: {expand}, {entry_args}")

            else:
                # leave field arg for later iterative replacement
                print_debug(f"ignored {entry_arg}, expand: {expand}, {entry_args}")

        elif entry_arg == "%U":
            if encountered_fu:
                raise RuntimeError(
                    f'Desktop entry has conflicting args: "{encountered_fu}", "{entry_arg}"'
                )
            encountered_fu = entry_arg

            # pop field arg
            entry_args.pop(idx + expand)
            expand -= 1
            print_debug(f"popped {entry_arg}, expand: {expand}, {entry_args}")

            # replace with arguments
            for arg in args:
                # urify if not an url, assume file
                arg = path2url(arg)
                entry_args.insert(idx + expand, arg)
                expand += 1
                print_debug(f"added {arg}, expand: {expand}, {entry_args}")

        elif entry_arg == "%c":
            entry_args[idx + expand] = entry_dict["Name"]
            print_debug(f"replaced, expand: {expand}. {entry_args}")
        elif entry_arg == "%k":
            entry_args[idx + expand] = entry_dict["filename"]
            print_debug(f"replaced, expand: {expand}. {entry_args}")
        elif entry_arg == "%i":
            if entry_dict["Icon"]:
                entry_args[idx + expand] = "--icon"
                entry_args.insert(idx + expand + 1, entry_dict["Icon"])
                expand += 1
                print_debug(f"replaced and expanded, expand: {expand}. {entry_args}")
            else:
                entry_args.pop(idx + expand)
                expand -= 1
                print_debug(f"popped, expand: {expand}")

    print_debug("entry_cmd, entry_args post:", entry_cmd, entry_args)

    # fail if arguments not supported, but requested
    if args and not encountered_fu and entry_action:
        raise RuntimeError(
            f'Entry "{os.path.basename(entry.filename)}" action "{entry_action}" does not support arguments'
        )

    if args and not encountered_fu and not entry_action:
        raise RuntimeError(
            f'Entry "{os.path.basename(entry.filename)}" does not support arguments'
        )

    # iterative arguments required
    if len(args) > 1 and encountered_fu in ["%f", "%u"]:
        iterated_entry_args = []
        field_index = entry_args.index(encountered_fu)
        for arg in args:
            cur_entry_args = entry_args.copy()
            if encountered_fu == "%u":
                arg = path2url(arg)
            cur_entry_args[field_index] = arg
            iterated_entry_args.append(cur_entry_args)
            print_debug("added iter args", cur_entry_args)

        return (entry_cmd, iterated_entry_args)

    return (entry_cmd, entry_args)


def app(cmd, cmd_args, slice_name, app_unit_type, app_name, unit_name, fork=False):
    """
    Exec given command or desktop entry via systemd-run in specific scope.
    Or fork and return subprocess object.
    """

    # parse desktop entry, update cmd, cmd_args, app_name
    if cmd.endswith(".desktop") or (
        ".desktop:" in cmd and not cmd.endswith(".desktop:")
    ):
        # separate action
        if ":" in cmd and cmd.count(":") == 1:
            entry_name, entry_action = cmd.split(":")
        elif ":" in cmd and cmd.count(":") > 1:
            raise ValueError(f'Invalid desktop entry with action "{cmd}"')
        else:
            entry_name, entry_action = cmd, ""

        if not entry_name:
            raise ValueError(f'Invalid desktop entry with action string "{cmd}"')

        print_debug("entry_name, entry_action:", entry_name, entry_action)

        entry = get_de(entry_name, subpath="applications")

        if not entry:
            raise FileNotFoundError(f'Could not find or parse deskop entry "{cmd}"')

        # get unlocalized entry name if no override
        if not app_name:
            app_name = entry.get("Name", locale=False)

        # regenerate command and args according to entry
        cmd, cmd_args = gen_entry_args(
            entry, cmd_args, entry_action=entry_action or None
        )

        # iterative execution is required
        if cmd_args and isinstance(cmd_args[0], (list, tuple)):
            # drop unit_name if multiple instances required
            if unit_name:
                print_warning(
                    f'Dropping unit name "{unit_name}" because entry "{os.path.basename(entry.filename)}" requires multiple instances for given arguments'
                )
                unit_name = ""

            # call forking self for each instance
            sub_apps = []
            for args_instance in cmd_args:
                sub_apps.append(
                    app(
                        cmd,
                        args_instance,
                        slice_name,
                        app_unit_type,
                        app_name,
                        unit_name,
                        fork=True,
                    )
                )

            # prepare poll registry
            sub_apps_rc = [None for n in range(0, len(sub_apps))]

            # function for map()
            def is_int(checkvar):
                "checks if given var is int"
                return isinstance(checkvar, int)

            # poll subprocesses until they are finished
            while not all(map(is_int, sub_apps_rc)):
                for idx, sub_app in enumerate(sub_apps):
                    if not is_int(sub_apps_rc[idx]):
                        sub_apps_rc[idx] = sub_app.poll()
                        if is_int(sub_apps_rc[idx]) and sub_apps_rc[idx]:
                            print_error(
                                f'Process "{shlex.join(sub_app.args)}" finished with {sub_apps_rc[idx]}'
                            )
                        elif is_int(sub_apps_rc[idx]) and not sub_apps_rc[idx]:
                            print_normal(
                                f'Process "{shlex.join(sub_app.args)}" finished with {sub_apps_rc[idx]}'
                            )
                time.sleep(0.1)

            if any(sub_apps_rc):
                sys.exit(1)
            sys.exit(0)

    print_debug("cmd", cmd, "cmd_args", cmd_args)

    if slice_name == "a":
        slice_name = "app-graphical.slice"
    elif slice_name == "b":
        slice_name = "background-graphical.slice"
    elif slice_name == "s":
        slice_name = "session-graphical.slice"
    elif slice_name.endswith(".slice"):
        # slice_name = slice_name
        pass
    else:
        print_error(f"Invalid slice name: {slice_name}")
        sys.exit(1)

    if not unit_name:
        # use XDG_SESSION_DESKTOP as part of scope name
        sprc = subprocess.run(
            ["systemd-escape", os.getenv("XDG_SESSION_DESKTOP", "uwsm")],
            text=True,
            capture_output=True,
            check=False,
        )
        print_debug(sprc)

        if sprc.returncode != 0 or not sprc.stdout.strip():
            print_error(sprc.stderr.strip())
            print_error("Could not escape sequence for scope name")
            sys.exit(1)
        desktop_unit_substring = sprc.stdout.strip()

        # use app cmd as part of scope name
        sprc = subprocess.run(
            ["systemd-escape", app_name or os.path.basename(cmd)],
            text=True,
            capture_output=True,
            check=False,
        )
        print_debug(sprc)

        if sprc.returncode != 0 or not sprc.stdout.strip():
            print_error(sprc.stderr.strip())
            print_error("Could not escape sequence for scope name")
            sys.exit(1)
        cmd_unit_substring = sprc.stdout.strip()

        unit_name = f"app-{desktop_unit_substring}-{cmd_unit_substring}-{random_hex(8)}.{app_unit_type}"
    else:
        if not unit_name.endswith(f".{app_unit_type}"):
            raise ValueError(
                f'Only ".{app_unit_type}" is supported as unit suffix for {app_unit_type} unit type'
            )

    final_args = (
        "systemd-run",
        "--user",
        *(["--scope"] if app_unit_type == "scope" else []),
        "--slice",
        slice_name,
        "-u",
        unit_name,
        "-qG",
        "--",
        cmd,
        *(cmd_args),
    )

    print_debug("final_args", *(final_args))

    if fork:
        return subprocess.Popen(final_args)

    os.execlp(final_args[0], *(final_args))


def fill_wm_globals():
    """
    Fills global vars:
      wm_argv
      wm_cli_args
      wm_id
      wm_bin_id
      wm_desktop_names
      wm_cli_desktop_names
      wm_cli_desktop_names_exclusive
      wm_name
      wm_cli_name
      wm_description
      wm_cli_description
    based on args or desktop entry
    """

    global wm_argv
    global wm_cli_args
    global wm_id
    global wm_bin_id
    global wm_desktop_names
    global wm_cli_desktop_names
    global wm_cli_desktop_names_exclusive
    global wm_name
    global wm_cli_name
    global wm_description
    global wm_cli_description

    wm_id = args.wm

    if not wm_id:
        print_error("WM is not provided")
        parsers["start"].print_help(file=sys.stderr)
        sys.exit(1)

    if not re.search(r"\A[a-zA-Z0-9_:.-]+\Z", wm_id, flags=re.MULTILINE):
        print_error(f'"{wm_id}" does not conform to "^[a-zA-Z0-9_.-]+$" pattern')
        sys.exit(1)

    if wm_id.endswith(".desktop") or (
        ".desktop:" in wm_id and not wm_id.endswith(".desktop:")
    ):
        print_debug(f"WM ID is a desktop entry: {wm_id}")

        # separate action
        if ":" in wm_id and wm_id.count(":") == 1:
            entry_name, entry_action = wm_id.split(":")
        elif ":" in wm_id and wm_id.count(":") > 1:
            raise ValueError(f'Invalid desktop entry with action "{wm_id}"')
        else:
            entry_name, entry_action = wm_id, ""

        if not entry_name:
            raise ValueError(f'Invalid desktop entry with action string "{wm_id}"')

        # parse entry
        try:
            # find and parse entry
            entry = get_de(entry_name)
            if not entry:
                raise FileNotFoundError(f'Could not find and parse entry "{wm_id}"')
        except Exception as caught_exception:
            print_error_or_traceback(caught_exception)
            sys.exit(1)

        print_debug("entry", entry)

        entry_dict = entry2dict(entry, entry_action=entry_action or None)

        # combine exec from entry and arguments
        # TODO: either drop this behavior, or add support for % fields
        # not that wayland session entries will ever use them
        wm_argv = shlex.split(entry_dict["Exec"]) + args.args

        # this does not happen in aux exec mode
        if "desktop_names" in args:
            # check desktop names
            if args.desktop_names and not re.search(
                r"\A[a-zA-Z0-9_.-]+(:[a-zA-Z0-9_.-]+)*\Z",
                args.desktop_names,
                flags=re.MULTILINE,
            ):
                print_error(f"Got malformed desktop names: {args.desktop_names}")
                sys.exit(1)
            # set exclusive desktop names
            if args.desktop_names_exclusive and args.desktop_names:
                wm_desktop_names = sane_split(args.desktop_names, ":")
            # error out on conflicting args
            if args.desktop_names_exclusive and not args.desktop_names:
                print_error(
                    'Requested exclusive desktop names ("-e") but no desktop names were given via "-D"'
                )
                sys.exit(1)
            # prepend desktop names from entry
            else:
                if entry_dict["DesktopNames"]:
                    wm_desktop_names = (
                        entry_dict["DesktopNames"]
                        + [wm_argv[0]]
                        + sane_split(args.desktop_names, ":")
                    )
                else:
                    wm_desktop_names = [wm_argv[0]] + sane_split(
                        args.desktop_names, ":"
                    )

            if args.wm_name:
                wm_name = args.wm_name
            elif entry_dict["Name"] and not entry_dict["GenericName"]:
                wm_name = entry_dict["Name"]
            elif not entry_dict["Name"] and entry_dict["GenericName"]:
                wm_name = f"{wm_argv[0]} {entry_dict['GenericName']}"
            elif entry_dict["Name"] and entry_dict["GenericName"]:
                wm_name = f"{entry_dict['Name']} {entry_dict['GenericName']}"

            if args.wm_comment:
                wm_description = args.wm_comment
            else:
                wm_description = entry_dict["Comment"]

    else:
        # WM id is an executable
        # check exec
        if not which(wm_id):
            print_error(f'"{wm_id}" is not in PATH.')
            sys.exit(1)

        # combine argv
        wm_argv = [wm_id] + args.args

        # this does not happen in aux exec mode
        if "desktop_names" in args:
            # fill other data
            if args.desktop_names_exclusive:
                wm_desktop_names = sane_split(args.desktop_names, ":")
            else:
                wm_desktop_names = [wm_argv[0]] + sane_split(args.desktop_names, ":")
            wm_name = args.wm_name
            wm_description = args.wm_comment

    # fill cli-exclusive vars for reproduction in unit drop-ins
    wm_cli_args = args.args
    # this does not happen in aux exec mode
    if "desktop_names" in args:
        wm_cli_desktop_names = sane_split(args.desktop_names, ":")
        wm_cli_desktop_names_exclusive = args.desktop_names_exclusive
        wm_cli_name = args.wm_name
        wm_cli_description = args.wm_comment

        # deduplicate desktop names preserving order
        ddn = []
        for desktop_name in wm_cli_desktop_names:
            if desktop_name not in ddn:
                ddn.append(desktop_name)
        wm_cli_desktop_names = ddn
        ddn = []
        for desktop_name in wm_desktop_names:
            if desktop_name not in ddn:
                ddn.append(desktop_name)
        wm_desktop_names = ddn

    # id for functions and env loading
    wm_bin_id = re.sub("(^[^a-zA-Z]|[^a-zA-Z0-9_])+", "_", wm_argv[0])

    return True


def stop_wm():
    "Stops WM if active, returns int returncode"
    if is_active():
        print_normal("Stopping WM")
        if not args.dry_run:
            sprc = subprocess.run(
                ["systemctl", "--user", "stop", "wayland-wm@*.service"],
                text=True,
                capture_output=True,
                check=False,
            )
            print_debug(sprc)
            if sprc.stdout.strip():
                print_normal(sprc.stdout.strip())
            if sprc.stderr.strip():
                print_error(sprc.stderr.strip())
            returncode = sprc.returncode
        else:
            returncode = 0
    else:
        print_normal("WM is not running")
        returncode = 0

    return returncode


def trap_stopper(signal=0, stack_frame=None):
    "For use in signal trap. Stops wm and exits."
    if signal == 0:
        # reuse second arg for systemctl returncode
        print_normal(f"systemctl returned {stack_frame}")
    else:
        print(f"Received signal {signal}, stopping WM...")
        print_debug(stack_frame)

    returncode = stop_wm()
    if returncode != 0:
        print_error(f"Stop returned {returncode}")

    sys.exit(returncode)


if __name__ == "__main__":
    # define globals
    units_changed: bool = False
    wm_argv: List[str] = []
    wm_cli_args: List[str] = []
    wm_id: str = ""
    wm_bin_id: str = ""
    wm_desktop_names: List[str] = []
    wm_cli_desktop_names: List[str] = []
    wm_cli_desktop_names_exclusive: bool = False
    wm_name: str = ""
    wm_cli_name: str = ""
    wm_description: str = ""
    wm_cli_description: str = ""

    # get args and parsers (for help)
    args, parsers = parse_args()

    print_debug("args", args)

    #### START
    if args.mode == "start":
        # Get ID from whiptail menu
        if args.wm in ["select", "default"]:
            try:
                select_wm_id = select_de()
                if select_wm_id:
                    save_default_de(select_wm_id)
                    # update args.wm in place
                    args.wm = select_wm_id
                else:
                    print_error("No WM was selected")
                    sys.exit(1)
            except Exception as caught_exception:
                print_error_or_traceback(caught_exception)
                sys.exit(1)

        fill_wm_globals()

        print_normal(
            dedent(
                f"""
                    Selected WM ID: {wm_id}
                      Command Line: {shlex.join(wm_argv)}
                  Plugin/binary ID: {wm_bin_id}
                     Desktop Names: {':'.join(wm_desktop_names)}
                              Name: {wm_name}
                       Description: {wm_description}
                """
            )
        )

        if is_active(verbose=True):
            print_error("Another WM is already running.")
            if not args.dry_run:
                sys.exit(1)
            else:
                print_ok("...but this is dry run, so the dream continues.")

        generate_units()

        if units_changed:
            reload_systemd()
        else:
            print_normal("Units unchanged")

        if args.only_generate:
            print_warning("Only unit creation was requested. Will not go further.")
            sys.exit(0)

        if args.dry_run:
            print_normal(f"Will start {wm_id}...")
        else:
            print_normal(f"Starting {wm_id}...")

        sprc = subprocess.run(
            ["systemctl", "is-active", "-q", "graphical.target"],
            text=True,
            capture_output=True,
            check=False,
        )
        print_debug(sprc)
        if sprc.returncode != 0:
            print_warning(
                dedent(
                    """
                    System has not reached graphical.target.
                    It might be a good idea to screen for this with a condition.
                    Will continue in 3 seconds...
                    """
                )
            )
            time.sleep(3)

        if args.dry_run:
            print_warning("Dry Run Mode. Will not go further.")
            sys.exit(0)

        # trap exit on INT TERM HUP
        signal.signal(signal.SIGINT, trap_stopper)
        signal.signal(signal.SIGTERM, trap_stopper)
        signal.signal(signal.SIGHUP, trap_stopper)

        sprc = subprocess.run(
            ["systemctl", "--user", "start", "--wait", f"wayland-wm@{wm_id}.service"],
            check=False,
        )
        print_debug(sprc)

        # in case systemctl is killed, run trap_stopper.
        # reuse second arg for systemctl returncode
        trap_stopper(0, sprc.returncode)

    #### STOP
    elif args.mode == "stop":
        returncode = stop_wm()
        if returncode != 0:
            print_error(f"Stop returned {returncode}")

        # args.remove_units is False when not given, None if given without argument
        if args.remove_units is not False:
            remove_units(args.remove_units)
            if units_changed:
                reload_systemd()
            else:
                print_normal("Units unchanged")

        sys.exit(returncode)

    #### FINALIZE
    elif args.mode == "finalize":
        finalize(args.env_names)

    #### APP
    elif args.mode == "app":
        try:
            app(
                cmd=args.cmd,
                cmd_args=args.args,
                slice_name=args.slice_name,
                app_unit_type=args.app_unit_type,
                app_name=args.app_name,
                unit_name=args.unit_name,
            )
        except Exception as caught_exception:
            print_error_or_traceback(caught_exception)
            sys.exit(1)

    #### CHECK
    elif args.mode == "check" and args.checker == "is-active":
        if is_active(args.wm, args.verbose):
            sys.exit(0)
        else:
            sys.exit(1)

    elif args.mode == "check" and args.checker == "may-start":
        dealbreakers = []
        if is_active():
            dealbreakers.append("Another WM is running")

        # check if parent process is a login shell
        try:
            with open(
                f"/proc/{os.getppid()}/cmdline", "r", encoding="UTF-8"
            ) as ppcmdline:
                parent_cmdline = ppcmdline.read()
                parent_cmdline = parent_cmdline.strip()
            print_debug(f"parent_pid: {os.getppid()}")
            print_debug(f"parent_cmdline: {parent_cmdline}")
        except Exception as caught_exception:
            print_error("Could not determine parent process command")
            print_error_or_traceback(caught_exception)
            sys.exit(1)
        if not parent_cmdline.startswith("-"):
            dealbreakers.append("Not in login shell")

        # check foreground VT
        fgvt = get_fg_vt()
        if fgvt is None:
            dealbreakers.append("Could not determine foreground VT")
        else:
            # argparse does not pass default for this
            allowed_vtnr = args.vtnr or [1]
            if fgvt not in allowed_vtnr:
                dealbreakers.append(
                    f"Foreground VT ({fgvt}) is not among allowed VTs ({'|'.join([str(v) for v in allowed_vtnr])})"
                )

        # check for graphical target
        sprc = subprocess.run(
            ["systemctl", "is-active", "-q", "graphical.target"],
            text=True,
            capture_output=True,
            check=False,
        )
        print_debug(sprc)
        if sprc.stdout.strip():
            print_normal(sprc.stdout.strip())
        if sprc.stderr.strip():
            print_normal(sprc.stderr.strip())
        if sprc.returncode != 0:
            dealbreakers.append("System has not reached graphical.target")

        if dealbreakers:
            if args.verbose:
                print_warning("\n".join(["May not start WM:"] + dealbreakers))
            sys.exit(1)
        else:
            if args.verbose:
                print_ok("May start WM")
            sys.exit(0)

    #### AUX
    elif args.mode == "aux":
        manager_pid = int(os.getenv("MANAGERPID", ""))
        ppid = int(os.getppid())
        print_debug(f"manager_pid: {manager_pid}, ppid: {ppid}")
        if not manager_pid or manager_pid != ppid:
            print_error("Aux actions can only be run by systemd user manager")
            sys.exit(1)

        if args.aux_action == "prepare-env":
            fill_wm_globals()
            try:
                prepare_env()
                sys.exit(0)
            except Exception as caught_exception:
                print_error_or_traceback(caught_exception)
                try:
                    cleanup_env()
                except Exception as caught_exception:
                    print_error_or_traceback(caught_exception)
                sys.exit(1)
        elif args.aux_action == "cleanup-env":
            if is_active("", True):
                print_error("A WM is running, will not cleanup environment")
                sys.exit(1)
            else:
                try:
                    cleanup_env()
                    sys.exit(0)
                except Exception as caught_exception:
                    print_error_or_traceback(caught_exception)
                    sys.exit(1)
        elif args.aux_action == "exec":
            fill_wm_globals()
            print_debug(wm_argv)
            print_normal(f"Starting: {shlex.join(wm_argv)}")
            os.execlp(wm_argv[0], *(wm_argv))
