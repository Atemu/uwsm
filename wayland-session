#!/bin/sh


# Universal wayland desktop session manager
# Runs selected compositor with plugin-extendable tweaks
# Manages systemd environment and targets along the way
# Inspired by and uses some parts from https://github.com/xdbob/sway-services

SUPPORTED_COMPOSITORS=''
SUPPORTED_MODES='start|intstart|stop|cleanup|check'
PLUGIN_PREFIX_PATHS="/lib:/usr/lib:${HOME}/.local/lib"
PLUGIN_DIR_NAME=wayland-session-plugins

START_STOP_RETRIES=10

# variables that will always be exported to systemd user manager during startup
ALWAYS_EXPORT_VARS="XDG_SESSION_ID
XDG_CURRENT_DESKTOP
XDG_SESSION_DESKTOP
XDG_MENU_PREFIX
PATH"

# variables that will be imported back from systemd user manager during startup
IMPORT_BACK_VARS="DISPLAY
WAYLAND_DISPLAY
SSH_AGENT_LAUNCHER
SSH_AUTH_SOCK
SSH_AGENT_PID"

# variables that will never be cleaned up from systemd user manager during shutdown
NEVER_CLEANUP_VARS="SSH_AGENT_LAUNCHER
SSH_AUTH_SOCK
SSH_AGENT_PID"

# variables that will always be cleaned up from systemd user manager during shutdown
ALWAYS_CLEANUP_VARS="DISPLAY
WAYLAND_DISPLAY
XDG_SESSION_ID
XDG_CURRENT_DESKTOP
XDG_SESSION_DESKTOP
XDG_MENU_PREFIX
XCURSOR_SIZE"

show_help() {
	cat <<- EOF
		
		Generic wayland session manager with systemd integration
		Usage:
		  $(basename $0) ${SUPPORTED_COMPOSITORS:-supported_compositor} ${SUPPORTED_MODES}
		
		$(basename $0) manages session for selected wayland compositor.
		Modes:
		  start:     starts session of selected compositor
		  intstart:  reexec self in start mode with full systemd-cat logging not just compositor
		  stop:      cleanly shuts down session or cleans up environment
		             just killing main session manager process is also supported
		  cleanup:   cleans up environment from systemd user manager if main process is not running
		  check:     checks supported arguments
		
		Session manager also loads environment from \${COMPOSITOR}/env files in
		\${XDG_CONFIG_DIRS}:\${XDG_CONFIG_HOME} dirs (in order of increasing importance)
		
		See code comments for documentation on plugins.
	EOF
}

# functions for use in plugins
add_supported_compositor() {
	# takes simple executable name
	if echo "$1" | grep -qE "^[a-zA-Z0-9_-]+$" && [ "$(echo "$1" | wc -l)" = "1" ]
	then
		SUPPORTED_COMPOSITORS="${SUPPORTED_COMPOSITORS}${SUPPORTED_COMPOSITORS:+|}${1}"
		echo "Added supported compositor $1"
	else
		echo "Attempted to add invalid compositor name" >&2
		echo "$1" >&2
		exit 1
	fi
}

# load plugins
# plugins should contain only add_supported_compositor call
# and specifically named functions
# example:
#  add_supported_compositor sway
#  # function to make arbitrary actions before startup and loading ${COMPOSITOR}/env
#  quirks_sway() {
#    # here additional vars can be added set for session manager
#    # like
#    IMPORT_BACK_VARS="${IMPORT_BACK_VARS} SWAYSOCK I3SOCK"
#    ALWAYS_EXPORT_VARS="${ALWAYS_EXPORT_VARS} SOME OTHER VARS"
#    ALWAYS_CLEANUP_VARS"${ALWAYS_CLEANUP_VARS} SOME OTHER VARS"
#    # or export more vars for session
#    export I_WANT_THIS_IN_SESSION=yes
#    # or prepare a config (see waybar plugin)
#    # or set a var to modify what ${COMPOSITOR}/env will do
#    ...
#  }
#  # Function to override compositor execution.
#  # Always define compositor as arguments to compositor_wrapper
#  run_compositor_sway() {
#    compositor_wrapper sway --with any args
#  }
#  # function to terminate compositor
#  exit_sway() {
#    # requires SWAYSOCK in IMPORT_BACK_VARS
#    swaymsg exit
#  }

OIFS="$IFS"
IFS=":"
for PLUGIN_PREFIX_PATH in $PLUGIN_PREFIX_PATHS
do
	if [ -d "${PLUGIN_PREFIX_PATH}/${PLUGIN_DIR_NAME}" ]
	then
		IFS="
"
		for PFILE in $(
			find "${PLUGIN_PREFIX_PATH}/${PLUGIN_DIR_NAME}/"\
			  -mindepth 1 -maxdepth 1 \
			  -type f -name "*.plugin.sh"
		)
		do
			echo "Loading plugin: $PFILE"
			. "$PFILE"
		done
	fi
done
IFS="$OIFS"

if echo "$*" | grep -qE '(^| )(--help|-h)( |$)'
then
	show_help
	exit 0
fi

COMPOSITOR="${1:?Requires a compositor as first argument: $SUPPORTED_COMPOSITORS}"
MODE="${2:?Requires a mode of action as second argument: $SUPPORTED_MODES}"

CHECKOUT=true

if ! echo "$MODE" | grep -qE "^(${SUPPORTED_MODES})$"
then
	echo "Mode $MODE not supported, choose $SUPPORTED_MODES" >&2
	CHECKOUT=false
fi

if ! echo "$COMPOSITOR" | grep -qE "^[a-zA-Z0-9_-]+$"
then
	echo "Got malformed compositor name: $COMPOSITOR" >&2
	CHECKOUT=false
fi

if ! [ -x "$(which "$COMPOSITOR")" ]
then
	echo "$COMPOSITOR is not an executable binary" >&2
	CHECKOUT=false
fi

if ! echo "$COMPOSITOR" | grep -qE "^(${SUPPORTED_COMPOSITORS})$"
then
	echo "Compositor $COMPOSITOR not supported, choose $SUPPORTED_COMPOSITORS" >&2
	CHECKOUT=false
fi

# exit with error on failed checks
if [ "$CHECKOUT" = "false" ]
then
	exit 1
elif [ "$MODE" = "intstart" ]
then
	echo "Doing integrated start"
	exec systemd-cat -t "wayland-session-${COMPOSITOR}-manager" -- "$0" "$COMPOSITOR" start
fi

normalize_varnames_space() {
	# pipe var names to get sorted, uniqued, normalized space-separated output
	tr ' \t\n' '\n\n\n' | tr -s '\n' | sort -u | tr '\n' ' ' | sed 's/^ \+\| \+$//g'
}

normalize_varnames_newline() {
	# pipe var names to get sorted, uniqued, normalized newline-separated output
	tr ' \t\n' '\n\n\n' | tr -s '\n' | sort -u
}

varnames_subtract() {
	# pipe in list 1, get list 2 on args, output diff newline-separated output (comm)
	RND=$(grep -ao '[[:xdigit:]]' /dev/urandom| head -n 10 | tr -d '\n' )
	normalize_varnames_newline > "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_list_1_${RND}"
	echo $* | normalize_varnames_newline > "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_list_2_${RND}"
	comm -23 "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_list_1_${RND}" "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_list_2_${RND}"
	rm -f "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_list_1_${RND}" "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_list_2_${RND}"
}

varnames_intersect() {
	# pipe in list 1, get list 2 on args, output intersection newline-separated output (comm)
	RND=$(grep -ao '[[:xdigit:]]' /dev/urandom | head -n 10 | tr -d '\n' )
	normalize_varnames_newline > "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_list_1_${RND}"
	echo $* | normalize_varnames_newline > "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_list_2_${RND}"
	comm -12 "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_list_1_${RND}" "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_list_2_${RND}"
	rm -f "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_list_1_${RND}" "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_list_2_${RND}"
}

varnames_union() {
	# pipe in list 1, get list 2 on args, output merged newline-separated output
	{
		normalize_varnames_newline
		echo $* | normalize_varnames_newline
	} | sort -u
}

generate_units() {
	# injects customized targets bound to systemd special graphical targets
	mkdir -p "${XDG_RUNTIME_DIR}/systemd/user/"
	echo "Placing ${XDG_RUNTIME_DIR}/systemd/user/wayland-session-pre@.target"
	cat > "${XDG_RUNTIME_DIR}/systemd/user/wayland-session-pre@.target" <<- EOF
		# injected by $(basename "$0"), do not edit
		[Unit]
		Description=Session services which should run early before the %I session is brought up
		Documentation=man:systemd.special(7)
		Requires=basic.target
		#StopWhenUnneeded=yes
		BindsTo=graphical-session-pre.target
		Before=graphical-session-pre.target
	EOF
	echo "Placing ${XDG_RUNTIME_DIR}/systemd/user/wayland-session@.target"
	cat > "${XDG_RUNTIME_DIR}/systemd/user/wayland-session@.target" <<- EOF
		# injected by $(basename "$0"), do not edit
		[Unit]
		Description=Session of %I Wayland Window Manager
		Documentation=man:systemd.special(7)
		Requires=wayland-session-pre@%i.target
		After=wayland-session-pre@%i.target
		#StopWhenUnneeded=yes
		BindsTo=graphical-session.target
		Before=graphical-session.target
	EOF
	echo "Placing ${XDG_RUNTIME_DIR}/systemd/user/wayland-session-xdg-autostart@.target"
	cat > "${XDG_RUNTIME_DIR}/systemd/user/wayland-session-xdg-autostart@.target" <<- EOF
		# injected by $(basename "$0"), do not edit
		[Unit]
		Description=XDG Autostart of %I Wayland Window Manager
		Documentation=man:systemd.special(7)
		Requires=wayland-session@%i.target
		After=wayland-session@%i.target
		#StopWhenUnneeded=yes
		BindsTo=xdg-desktop-autostart.target
		Before=xdg-desktop-autostart.target
	EOF
	#echo "Placing ${XDG_RUNTIME_DIR}/systemd/user/wayland-wm@.service"
	#cat > "${XDG_RUNTIME_DIR}/systemd/user/wayland-session-xdg-autostart@.target" <<- EOF
	#	# injected by $(basename "$0"), do not edit
	#	[Unit]
	#	Description=%I Wayland Window Manager
	#	Documentation=man:systemd.service(7)
	#	BindsTo=wayland-session@%i.target
	#	#Before=wayland-session@%i.target
	#	Wants=wayland-session-pre@%i.target
	#	After=wayland-session-pre@%i.target
	#	#StopWhenUnneeded=yes
	#	[Service]
	#	Type=notify
	#	ExecStart=/usr/bin/env %I
	#	Restart=on-failure
	#	RestartSec=1
	#	TimeoutStopSec=10
	#	NotifyAccess=all
	#EOF
	echo Reloading systemd user manager
	systemctl --user daemon-reload
}

compositor_wrapper() {
	# receives compositor execution args
	# wraps compositor into scope
	# adds stop propagation from -pre target (for shutdown)
	# wraps into systemd-cat for logging
	systemd-run --user --scope \
	  --unit="wayland-session-${COMPOSITOR}" \
	  --description="Scope for ${COMPOSITOR} wayland compositor and its children" \
	  --send-sighup \
	  --property="StopPropagatedFrom=wayland-session-pre@${COMPOSITOR}.target" \
	  -- \
	  systemd-cat -t "wayland-session-${COMPOSITOR}" \
	  -- \
	  "$@"
}

list_active_part_of() {
	# find active units that are PartOf $1, echo back
	for unit in $(systemctl --user --no-legend --plain list-units --state=active | cut -d ' ' -f 1)
	do
		partof="$(systemctl --user show -p PartOf --value -- "$unit")"
		if [ "$partof" = "$1" ]
		then
			echo "$unit"
		fi
	done
}

start_and_check() {
	# starts systemd unit and waits until it or second argument is up
	local COUNTER=${START_STOP_RETRIES}
	echo "Starting $1"
	systemctl --user start "$1"
	echo "Checking status of ${2:-$1}"
	while true
	do
		if [ "$COUNTER" -le "0" ]
		then
			echo Timed Out
			return 1
		else
			systemctl --user is-active "${2:-$1}" && return 0
		fi
		echo "Retries left: $COUNTER"
		sleep 1
		COUNTER=$(( $COUNTER - 1 ))
	done
}

import_back_vars() {
	# takes specific vars from systemd user manager environment and exports locally
	local __SC_ENV__=$(systemctl --user show-environment)
	local __VAR__=''
	local __VALUE__=''
	for __VAR__ in $*
	do
		local __VALUE__=$(
			printf %s "${__SC_ENV__}" \
			  | grep -E "^${__VAR__}=" \
		)
		if [ -n "${__VALUE__}" ]
		then
			# leave just value
			__VALUE__="${__VALUE__#*=}"
		else
			# var is not defined, skip
			continue
		fi
		echo "Importing back var ${__VAR__}"
		if printf %s "${__VALUE__}" | grep -qE "^\$'"
		then
			# we are probably in dash, so we have to expand a complex value
			__VALUE__="${__VALUE__#??}"
			__VALUE__="${__VALUE__%?}"
			__VALUE__=$(printf %b "${__VALUE__}")
		fi
		if export "${__VAR__}=${__VALUE__}"
		then
			echo "Imported ${__VAR__}"
		else
			echo "Failed importing ${__VAR__}" >&2
		fi
	done
}

cleanup_vars() {
	# take var names from "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_for_cleanup_env_names"
	# and ${ALWAYS_CLEANUP_VARS}
	# exclude ${NEVER_CLEANUP_VARS}
	# and remove them from systemd user manager
	local __VAR__
	local __ENV_NAMES_FOR_CLEANUP__=$(
		{
			# saved cleanup list if exists
			[ -f "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_for_cleanup_env_names" ] \
			  && cat "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_for_cleanup_env_names"
			# vars to always cleanup
			echo ${ALWAYS_CLEANUP_VARS}
			# subtract vars to never cleanup
		} | varnames_subtract ${NEVER_CLEANUP_VARS} | normalize_varnames_space
	)
	echo "Cleaning up variables:"
	__HAS_VARS__=false
	for __VAR__ in ${__ENV_NAMES_FOR_CLEANUP__}
	do
		__HAS_VARS__=true
		echo "  ${__VAR__}"
	done
	if [ "${__HAS_VARS__}" = "true" ]
	then
		systemctl --user unset-environment ${__ENV_NAMES_FOR_CLEANUP__}
		CLEANUP_RC=$?
	else
		echo "  No vars"
		CLEANUP_RC=0
	fi
	[ -f "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_for_cleanup_env_names" ] \
	  && rm "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_for_cleanup_env_names"
	return $CLEANUP_RC
}

shutdown_and_check() {
	# stop target and wait for children of it or arg 2 to die
	local COUNTER=${START_STOP_RETRIES}
	echo "Shutting down $1"
	if systemctl --user is-active -q "$1"
	then
		systemctl --user stop "$1"
	else
		echo "$1 is already inactive"
	fi

	echo "Waiting for depending units of ${1:-$2} to go down"
	while true
	do
		if  [ -z "$(list_active_part_of "${1:-$2}")" ] && ! systemctl --user is-active -q "${1:-$2}"
		then
			echo "${1:-$2} is down"
			return 0
		elif [ "$COUNTER" -le "0" ]
		then
			echo "timed out waiting for children of ${1:-$2} to die" >&2
			return 1
		fi
		echo "Retries left: $COUNTER"
		sleep 1
		COUNTER=$(( $COUNTER - 1))
	done
}

shutdown() {
	# TODO, replace pidfile with checking ExecMainStatus of a unit if we go with service
	echo "Shutting down $COMPOSITOR session"
	# stop autostart target
	shutdown_and_check "wayland-session-xdg-autostart@${COMPOSITOR}.target" xdg-desktop-autostart.target

	# stop graphical target
	shutdown_and_check "wayland-session@${COMPOSITOR}.target" graphical-session.target

	# if haven't caught compositor RC yet, try to kill it
	if [ -z "$COMPOSITOR_RC" ]
	then
		if kill -0 $COMPOSITOR_PID 2>/dev/null
		then
			# kill compositor via function if exists
			if type "exit_${COMPOSITOR}" >/dev/null
			then
				"exit_${COMPOSITOR}"
				EXIT_COMPOSITOR_RC=$?
				if [ "$EXIT_COMPOSITOR_RC" != "0" ]
				then
					echo "Compositor exit function returned $EXIT_COMPOSITOR_RC" >&2
				fi
			else
				kill $COMPOSITOR_PID
				KILL_COMPOSITOR_RC=$?
				if [ "$KILL_COMPOSITOR_RC" != "0" ]
				then
					echo "Killing compositor returned $KILL_COMPOSITOR_RC" >&2
				fi
			fi
		else
			echo "Compositor is already dead"
		fi
		wait $COMPOSITOR_PID
		COMPOSITOR_RC=$?
	fi
	if [ "$COMPOSITOR_RC" != "0" ]
	then
		echo "Compositor exited with RC $COMPOSITOR_RC" >&2
	fi

	shutdown_and_check "wayland-session-pre@${COMPOSITOR}.target" graphical-session-pre.target

	# check and terminate compositor scope
	if systemctl --user is-active -q "wayland-session-${COMPOSITOR}.scope"
	then
		echo "wayland-session-${COMPOSITOR}.scope is still active, terminating"
		shutdown_and_check "wayland-session-${COMPOSITOR}.scope"
	fi

	cleanup_vars

	if [ -f "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_pid" ]
	then
		rm "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_pid"
	fi

	exit "$COMPOSITOR_RC"
}

#### dir for saving var states
# (var is used just in this script for consistency in case of later overrides)
__LOCAL_RUNTIME_DIR__="${XDG_RUNTIME_DIR:-/run/user/$(id -u)}"

if [ "$MODE" = "check" ]
then
	# exit successfully after supported compositors check
	echo "Checked for compositor ${COMPOSITOR}"
	exit 0

elif [ "$MODE" = "cleanup" ]
then
	# abort cleanup if main process is still running
	if [ -f "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_pid" ]
	then
		MAINPID=$(cat "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_pid")
		if kill -0 $MAINPID 2>/dev/null
		then
			echo "Main process $MAINPID is still running, cleanup aborted" >&2
			exit 1
		fi
	fi

	# remove previously added environment vars and exit
	cleanup_vars
	exit

elif [ "$MODE" = "stop" ]
then
	if [ -f "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_pid" ]
	then
		MAIN_PID=$(cat "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_pid")
		echo Killing process $MAIN_PID
		kill $MAIN_PID
		KILL_RC=$?
		if [ "$KILL_RC" = "0" ]
		then
			rm "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_pid"
			exit 0
		else
			echo "Kill returned $KILL_RC, cleaning up vars instead"
			cleanup_vars
			rm "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_pid"
			exit $CLEANUP_RC
		fi
	else
		echo "Pidfile ${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_pid not found, cleaning up vars instead"
		cleanup_vars
		exit $CLEANUP_RC
	fi
fi

#### continue with "start" mode
# check and save main pid
if [ -f "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_pid" ]
then
	CHECK_PID=$(head -n 1 -c 8 "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_pid")
	if kill -0 $CHECK_PID 2>/dev/null
	then
		echo "Wayland session manager is already running as PID ${CHECK_PID}!" >&2
		exit 1
	fi
fi
echo $$ > "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_pid"

echo "Wayland session manager ($$) initiates startup sequence for ${COMPOSITOR}"

# create runtime targets
generate_units

#### begin env voodoo
# get current shell env names
__ENV_NAMES__=$(
	env -0 | cut -z -d '=' -f 1 | sort -z | tr '\0' ' ' | normalize_varnames_space
)

# get systemd user manager env names
__SYSTEMD_ENV_NAMES__=$(
	systemctl --user show-environment | cut -d '=' -f 1 | normalize_varnames_space
)

echo "Importing env difference from systemd user manager"
import_back_vars $(
	echo ${__SYSTEMD_ENV_NAMES__} \
	| varnames_subtract ${__ENV_NAMES__} \
	| normalize_varnames_space
)

# take full snapshot of env vars state (zero-delimited)
# this will be used for comparisons later
env -0 | sort -z > "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_initial_combined_env"

# collect env names
__ENV_NAMES__=$(
	env -0 | cut -z -d '=' -f 1 | sort -z | tr '\0' ' ' | normalize_varnames_space
)

#### Basic environment
. /etc/profile
[ -f "${HOME}/.profile" ] && . "${HOME}/.profile"
export PATH
export XDG_CONFIG_DIRS="${XDG_CONFIG_DIRS:-/etc/xdg}"
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-${HOME}/.config}"
export XDG_DATA_DIRS="${XDG_DATA_DIRS:-/usr/local/share:/usr/share}"
export XDG_DATA_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}"
export XDG_CACHE_HOME="${XDG_CACHE_HOME:-${HOME}/.cache}"
export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/$(id -u)}"

export XDG_CURRENT_DESKTOP="${COMPOSITOR}"
export XDG_SESSION_DESKTOP="${COMPOSITOR}"
export XDG_MENU_PREFIX="${COMPOSITOR}-"

#### apply quirks
if type "quirks_${COMPOSITOR}" >/dev/null
then
	echo "Applying quirks for ${COMPOSITOR}"
	quirks_${COMPOSITOR}
fi

#### iterate config dirs in increasing importance and source additional ${COMPOSITOR}/env
ALL_XDG_CONFIG_DIRS_REV=''
OIFS="$IFS"
IFS=":"
for CD in ${XDG_CONFIG_HOME}:${XDG_CONFIG_DIRS}
do
	# fill list in revers order
	ALL_XDG_CONFIG_DIRS_REV="${ALL_XDG_CONFIG_DIRS_REV}${ALL_XDG_CONFIG_DIRS_REV:+:}${CD}"
done
for CD in ${ALL_XDG_CONFIG_DIRS_REV}
do
	IFS="$OIFS"
	if [ -r "${CD}/${COMPOSITOR}/env" ]
	then
		echo "Loading environment from ${CD}/${COMPOSITOR}/env"
		#set -a
		. "${CD}/${COMPOSITOR}/env"
		#set +a
	fi
done
IFS="$OIFS"

# hardcode unset conflicting vars.
# if they were in systemd user manager environment,
# they will be automatically unset by the algorithm later
unset DISPLAY WAYLAND_DISPLAY

# take another zero-delimited snapshot of environment for comparison
env -0 | sort -z > "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_final_env"

# collect env names
__ENV_NAMES_AFTER__=$(
	env -0 | cut -z -d '=' -f 1 | sort -z | tr '\0' ' ' | normalize_varnames_space
)

# finalize export vars:
__ENV_NAMES_FOR_EXPORT__=$(
	{
		# names of vars modified since initial combined environment
		comm -z -13 \
		  "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_initial_combined_env" \
		  "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_final_env" \
		| cut -z -d '=' -f 1 \
		| tr '\0' '\n'

		# add defined subset of ${ALWAYS_EXPORT_VARS}
		echo ${ALWAYS_EXPORT_VARS} \
		| normalize_varnames_space \
		| varnames_intersect ${__ENV_NAMES_AFTER__} \
		| normalize_varnames_newline
	} | sort -u | normalize_varnames_space
)

# finalize unset vars:
# env vars that were in intial combined environment, but were explicitly unset since
__ENV_NAMES_FOR_UNSET__=$(
	echo ${__ENV_NAMES__} \
	| varnames_subtract ${__ENV_NAMES_AFTER__} \
	| normalize_varnames_space
)

# generate list of vars for cleanup after exit
__ENV_NAMES_FOR_CLEANUP__=$(
	{
		# names of env vars not yet present in systemd user manager, but going to
		echo ${__ENV_NAMES_FOR_EXPORT__} \
		  | varnames_subtract ${__SYSTEMD_ENV_NAMES__}
		# also add ${ALWAYS_CLEANUP_VARS}
		echo ${ALWAYS_CLEANUP_VARS}
		# then subtract ${NEVER_CLEANUP_VARS}
	} | normalize_varnames_space \
	  | varnames_subtract ${NEVER_CLEANUP_VARS} \
	  | normalize_varnames_space
)

# cleanup temp files
rm -f \
  ${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_initial_combined_env \
  ${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_final_env

# save cleanup list
echo ${__ENV_NAMES_FOR_CLEANUP__} \
  | normalize_varnames_newline \
  > "${__LOCAL_RUNTIME_DIR__}/${COMPOSITOR}_for_cleanup_env_names"

__HAS_VARS__=false
echo "Exporting vars to systemd user manager:"
for VAR in ${__ENV_NAMES_FOR_EXPORT__}
do
	__HAS_VARS__=true
	echo "  $VAR"
done

if [ "${__HAS_VARS__}" = "true" ]
then
	systemctl --user import-environment ${__ENV_NAMES_FOR_EXPORT__}
else
	echo "  No vars"
fi

__HAS_VARS__=false
echo "Unsetting vars from systemd user manager:"
for VAR in ${__ENV_NAMES_FOR_UNSET__}
do
	__HAS_VARS__=true
	echo "  $VAR"
done

if [ "${__HAS_VARS__}" = "true" ]
then
	systemctl --user unset-environment ${__ENV_NAMES_FOR_UNSET__}
else
	echo "  No vars"
fi

__HAS_VARS__=false
echo "Vars to be cleaned up from systemd user manager after exit:"
for VAR in ${__ENV_NAMES_FOR_CLEANUP__}
do
	__HAS_VARS__=true
	echo "  $VAR"
done
if [ "${__HAS_VARS__}" = "true" ]
then
	true
else
	echo "  No vars"
fi

#### startup sequence
# rig gracefull shutdown on signals
trap shutdown HUP TERM INT EXIT QUIT

# From: https://people.debian.org/~mpitt/systemd.conf-2016-graphical-session.pdf
# robustness: if the previous graphical session left some failed units,
# reset them so that they don't break this startup
for unit in $(systemctl --user --no-legend --state=failed --plain list-units | cut -f 1 -d ' ')
do
	partof="$(systemctl --user show -p PartOf --value -- "$unit")"
	for target in wayland-session@${COMPOSITOR}.target graphical-session.target
	do
		if [ "$partof" = "$target" ]
		then
			systemctl --user reset-failed "$unit"
			break
		fi
	done
done

echo "Declaring graphical-pre target"
start_and_check "wayland-session-pre@${COMPOSITOR}.target" graphical-session-pre.target

# early import back for stuff like ssh agents
import_back_vars $(echo ${IMPORT_BACK_VARS} | normalize_varnames_space)

echo "Executing ${COMPOSITOR} compositor"
if type "run_compositor_${COMPOSITOR}" > /dev/null 2> /dev/null
then
	"run_compositor_${COMPOSITOR}" &
	COMPOSITOR_PID=$!
else
	compositor_wrapper "${COMPOSITOR}" &
	COMPOSITOR_PID=$!
fi

# wait for DISPLAY or WAYLAND_DISPLAY to appear in systemd user manager env
# or for compositor to exit early
# compositor should run systemctl --user import-environment {DISPLAY|WAYLAND_DISPLAY}
echo "Waiting for environment injection from compositor"
COUNTER=${START_STOP_RETRIES}
while true
do
	sleep 1
	if ! kill -0 $COMPOSITOR_PID 2>/dev/null || [ "$COUNTER" -le "0" ]
	then
		echo "Compositor did not start or exited early, shutting down"
		shutdown
		break
	elif systemctl --user show-environment | grep -qE '^(DISPLAY|WAYLAND_DISPLAY)='
	then
		echo "Environment injection confirmed"
		break
	fi
	echo "Retries left: $COUNTER"
	COUNTER=$(( $COUNTER - 1 ))
done

echo "Declaring graphical target"
start_and_check "wayland-session@${COMPOSITOR}.target" graphical-session.target

import_back_vars $(echo ${IMPORT_BACK_VARS} | normalize_varnames_space)

echo "Declaring autostart target"
start_and_check "wayland-session-xdg-autostart@${COMPOSITOR}.target" xdg-desktop-autostart.target

echo "All session startup tasks completed"
wait $COMPOSITOR_PID
COMPOSITOR_RC=$!
shutdown
