#!/bin/sh

# Universal Wayland Desktop Session Manager
# Runs selected WM with plugin-extendable tweaks
# Manages systemd environment and targets along the way
# Inspired by and uses some techniques from:
#  https://github.com/xdbob/sway-services
#  https://github.com/alebastr/sway-systemd
#  https://github.com/swaywm/sway
#  https://people.debian.org/~mpitt/systemd.conf-2016-graphical-session.pdf

SUPPORTED_WMS=''
SUPPORTED_MODES='check|unitgen|prepare-env|start|stop|cleanup-env|unitrm'
PLUGIN_PREFIX_PATHS="/lib:/usr/lib:/usr/local/lib:${HOME}/.local/lib"
PLUGIN_DIR_NAME=wayland-session-plugins
PLUGIN_NAME_PATTERN='*.sh.in'

#### this is for testing
WS_EXEC="$(realpath -s "$0")"
# since script can be sourced, $0 is not reliable
WS_SELF=wayland-session
# wayland-wm-env@.service needs full path in case wayland-session is in ${USER}/.local/bin
# which most likely is not in PATH of systemd user manager when wayland-wm-env@.service starts
WS_SELF_FULL=$(which "$WS_SELF")
####

# variables that will always be exported to systemd user manager during startup
ALWAYS_EXPORT_VARS="XDG_SESSION_ID
XDG_VTNR
XDG_CURRENT_DESKTOP
XDG_SESSION_DESKTOP
XDG_MENU_PREFIX
PATH"

# variables that will never be exported to systemd user manager during startup
NEVER_EXPORT_VARS="PWD
LS_COLORS
INVOCATION_ID
SHLVL
SHELL"

# variables that will never be cleaned up from systemd user manager during shutdown
NEVER_CLEANUP_VARS="SSH_AGENT_LAUNCHER
SSH_AUTH_SOCK
SSH_AGENT_PID"

# variables that will always be cleaned up from systemd user manager during shutdown
ALWAYS_CLEANUP_VARS="DISPLAY
WAYLAND_DISPLAY
XDG_SESSION_ID
XDG_VTNR
XDG_CURRENT_DESKTOP
XDG_SESSION_DESKTOP
XDG_MENU_PREFIX
PATH
XCURSOR_THEME
XCURSOR_SIZE
LANG"

show_help() {
	cat <<- EOF
		
		Generic wayland session manager with systemd integration
		Usage:
		  ${WS_SELF} wm|'wm --with-args="any args"' ${SUPPORTED_MODES}
		
		Supported VMs: ${SUPPORTED_WMS:-No supported WMs}
		  Special value "select" will bring selection menu to choose from
		    'wayland-sessions' desktop entries.
		  Special value "default" will select saved or predefined cmd from
		    'wayland-session-default-cmd' file in config hierarchy,
		    or bring selection menu if default is missing or not among
		    'wayland-sessions' desktop entries.
		
		${WS_SELF} manages session for selected wayland WM.
		Supported modes:
		    check:     checks supported arguments
		
		    start:        does all unit preparations and starts WM via a service
		                  with --wait and a set of traps to bind to its life
		    stop:         stops wm
		
		If more control needed: more grained modes available:
		
		    unitgen:      generates systemd unit files in runtime hierarchy
		    prepare-env:  prepares environment for WM in systemd user manager
		                  (for use in ExecStart of wayland-wm-env@.service)
		    cleanup-env:  cleans up environment from systemd user manager
		                  (for use in ExecStop of wayland-wm-env@.service)
		    unitrm:       removes systemd unit files from runtime hierarchy
		
		    WM can be started this way:
		        ${WS_SELF} \${WM} unitgen
		        exec systemctl --user --wait start wayland-wm@\${WM}.service
		
		    Or binding it both ways to the login session:
		        ${WS_SELF} \${WM} unitgen
		        trap "if systemctl --user is-active -q wayland-wm@\${WM}.service ; then systemctl --user stop wayland-wm@\${WM}.service ; fi" INT TERM HUP EXIT
		        systemctl --user --wait start wayland-wm@\${WM}.service &
		        wait
		        exit
		
		${WS_SELF} also loads environment from "wayland-session-env" and "wayland-session-${WM}-env" files in
		\${XDG_CONFIG_DIRS}:\${XDG_CONFIG_HOME} dirs (in order of increasing importance)
		
		If your WM is systemd-aware and supports launching apps explicitly scoped in app.slice,
		or if you prefixed all app commands launched by WM with:
		
		    systemd-run --user --scope --slice=app.slice
		
		then you can put WM in session.slice (as recommended by man systemd.special) by setting
		
		    UWSM_USE_SESSION_SLICE=true
		
		This var affects unitgen phase, Slice= parameter of services.
		
		See code comments for documentation on plugins.
	EOF
}

# functions for use in plugins
add_supported_wm() {
	# takes simple executable name
	if echo "$1" | grep -qE "^[a-zA-Z0-9_-]+$" && [ "$(echo "$1" | wc -l)" = "1" ]
	then
		if echo "$1" | grep -qe "^(${SUPPORTED_WMS})\$"
		then
			echo "WM $1 is already supported"
		else
			SUPPORTED_WMS="${SUPPORTED_WMS}${SUPPORTED_WMS:+|}${1}"
			echo "Added supported WM $1"
		fi
		return 0
	else
		echo "Attempted to add invalid WM name" >&2
		echo "$1" >&2
		return 1
	fi
}

# load plugins
# plugins should contain only add_supported_wm call
# and specifically named functions
# function name suffix is expected to be WM executable name with
# all dashes and dots replaced by underscores and underscores singled
# $(echo "$WM" | tr '.-' '__' | tr -s '_')
# example:
#
#  #!/bin/false
#
#  add_supported_wm my-cool-wm
#
#  # function to make arbitrary actions before loading wayland-session-${WM}-env
#  quirks_my_cool_wm() {
#    # here additional vars can be added set for session manager
#    # like
#    IMPORT_BACK_VARS="${IMPORT_BACK_VARS} MY_WM_SOCKET"
#    ALWAYS_EXPORT_VARS="${ALWAYS_EXPORT_VARS} SOME OTHER VARS"
#    ALWAYS_CLEANUP_VARS"${ALWAYS_CLEANUP_VARS} SOME OTHER VARS"
#    # or export more vars for session
#    export I_WANT_THIS_IN_SESSION=yes
#    # or prepare a config (see wayfire plugin)
#    # or set a var to modify what wayland-session-${WM}-env in the next stage will do
#    ...
#  }
#
#  load_wm_env_my_cool_wm() {
#    # custom mechanism for loading of env (or a stub)
#    # completely replaces loading from wayland-session-${WM}-env in config dirs
#    # so repeat it
#    load_wm_env
#    # and add ours
#    load_config_env "${WM}/env"
#  }
#
#  generate_units_my_cool_wm() {
#    # place some units or fragments specifically for my-cool-wm
#    # use update_unit function
#    # reloading is handled by main script
#  }
#
#  remove_units_my_cool_wm() {
#    # remove the same units
#    # use remove_unit function
#    # reloading is handled by main script
#  }
#
#  # function to add/replace args for WM command
#  inject_args_my_cool_wm() {
#    # prepend some args before original args
#    WM_ARGS_PREPEND='-s --logmsg="foo bar"'
#    # on second thought, drop original args
#    WM_ARGS=''
#    # and append a bunch more
#    WM_ARGS_APPEND='--lifetime 1h'
#    my-cool-wm-communicate exit
#  }

OIFS="$IFS"
IFS=":"
for PLUGIN_PREFIX_PATH in $PLUGIN_PREFIX_PATHS
do
	if [ -n "$PLUGIN_PREFIX_PATH" ] && [ -n "$PLUGIN_DIR_NAME" ] && [ -n "$PLUGIN_NAME_PATTERN" ] && [ -d "${PLUGIN_PREFIX_PATH}/${PLUGIN_DIR_NAME}" ]
	then
		IFS="
"
		for PFILE in $(
			find -L "${PLUGIN_PREFIX_PATH}/${PLUGIN_DIR_NAME}/"\
			  -mindepth 1 -maxdepth 1 \
			  -type f -name "$PLUGIN_NAME_PATTERN"
		)
		do
			echo "Loading plugin: $PFILE"
			. "$PFILE"
		done
	fi
done
IFS="$OIFS"

if echo "$*" | grep -qE '(^| )(--help|-h)( |$)'
then
	show_help
	exit 0
fi

WM_CMD="${1:?Requires a compositor command line as first argument: $SUPPORTED_WMS}"
MODE="${2:?Requires a mode of action as second argument: $SUPPORTED_MODES}"

wm_selector() {
	# parse desktop entries of wayland-sessions, present choice via whiptail
	python <<- EOF
		try:
		    import os, sys, shlex
		    from xdg.DesktopEntry import DesktopEntry
		except ModuleNotFoundError as E:
		    print(E, file=sys.stderr)
		    sys.exit(126)
		
		def which(executable):
		    'Simple which'
		    for path in os.getenv('PATH', '').split(os.path.pathsep):
		        path = os.path.join(path, executable)
		        if os.path.exists(path) and os.access(path, os.X_OK):
		            return path
		    return ''
		
		def get_default_cmd():
		    'Gets WM command line from wayland-session-default-cmd file in config hierarchy'
		    for dir in [
		            os.getenv('XDG_CONFIG_HOME', os.path.join(os.getenv('HOME'), '.config')),
		            *(os.getenv('XDG_DATA_DIRS', '/etc/xdg').split(':'))
		        ]:
		        cmd_cache_file = os.path.join(dir, 'wayland-session-default-cmd')
		        if os.path.exists(cmd_cache_file):
		            try:
		                with open(cmd_cache_file, 'r') as opened_cmd_cache_file:
		                    for line in opened_cmd_cache_file.readlines():
		                        if line.strip():
		                            return line.strip()
		            except exception as E:
		                print(E, file=sys.stderr)
		                sys.exit(126)
		    return ''
		
		default = get_default_cmd()
		seen_entries = []
		entry_files = []
		choices = []
		
		# find relevant desktop entries as first found paths in data hierarchy
		for dir in [
		        os.getenv('XDG_DATA_HOME', os.path.join(os.getenv('HOME'), '.local/share')),
		        *(os.getenv('XDG_DATA_DIRS', '/usr/local/share:/usr/share').split(':'))
		    ]:
		    dir = os.path.join(dir, 'wayland-sessions')
		    if os.path.isdir(dir):
		        try:
		            os.chdir(dir)
		            for file in os.listdir():
		                if os.path.splitext(file)[1] == '.desktop' and file not in seen_entries:
		                    seen_entries.append(file)
		                    entry_files.append(os.path.join(dir, file))
		        except Exception as E:
		            print(E, file=sys.stderr)
		            sys.exit(126)
		
		# fill choces list with [Exec, Name], filtered
		for entry in entry_files:
		    try:
		        entry = DesktopEntry(entry)
		    except:
		        # just skip unparsable entry
		        continue
		    # skip inaccessible executables or hidden entries
		    if (
		        entry.getHidden()
		        or entry.getNoDisplay()
		        or (entry.getTryExec() and not entry.findTryExec())
		        or not entry.getExec()
		        or not which(shlex.split(entry.getExec())[0])
		    ):
		        continue
		    items = [entry.getExec(), entry.getName() or os.path.splitext(os.path.basename(entry.filename))[0]]
		    choices.extend(items)
		
		if len(choices) == 2 and default == choices[0]:
		    # just spit out the only preselected choice
		    print(choices[0], file=sys.stderr)
		    sys.exit(0)
		elif len(choices) > 2 and len(choices) % 2 == 0:
		    # drop default if not among choices
		    if default and default not in choices[::2]:
		        default = ''
		    elif default and os.getenv('__JUST_RUN_DEFAULT__', 'false') == 'true':
		        # just spit out default
		        for choice in choices[::2]:
		            if choice == default:
		                print(choice, file=sys.stderr)
		                sys.exit(0)
		elif len(choices) == 0:
		    print('No choices found', file=sys.stderr)
		    sys.exit(126)
		else:
		    print('Malformed choices', file=sys.stderr)
		    sys.exit(126)
		
		# generate arguments for whiptail exec
		argv = (
		    'whiptail',
		    'whiptail',
		    '--clear',
		    '--backtitle',
		    'Universal Wayland Session Manager',
		    '--title',
		    'Choose compositor',
		    '--nocancel',
		    *(
		        ('--default-item', default) if default else ()
		    ),
		    '--menu',
		    '',
		    '0',
		    '0',
		    '0',
		    '--notags',
		    *(choices)
		)
		
		# replace whiptail theme with simple default colors
		whiptail_env = dict(os.environ)
		whiptail_env.update({
		    'TERM': 'linux',
		    'NEWT_COLORS': ';'.join([
		        'root=default,default',
		        'border=default,default',
		        'window=default,default',
		        'shadow=default,default',
		        'title=black,lightgray',
		        'button=default,default',
		        'actbutton=black,lightgray',
		        'compactbutton=default,default',
		        'checkbox=default,default',
		        'actcheckbox=black,lightgray',
		        'entry=default,default',
		        'disentry=default,default',
		        'label=default,default',
		        'listbox=default,default',
		        'actlistbox=black,lightgray',
		        'sellistbox=black,lightgray',
		        'actsellistbox=black,lightgray',
		        'textbox=default,default',
		        'acttextbox=black,lightgray',
		        'emptyscale=default,default',
		        'fullscale=default,default',
		        'helpline=default,default',
		        'roottext=default,default'
		    ])
		})
		
		os.execlpe(*argv, whiptail_env)
	EOF
}

if [ "$WM_CMD" = "select" ] || [ "$WM_CMD" = "default" ]
then
	[ "$WM_CMD" = "select" ] && export __JUST_RUN_DEFAULT__=false
	[ "$WM_CMD" = "default" ] && export __JUST_RUN_DEFAULT__=true
	WM_CMD=$(wm_selector 3>&1 1>&2 2>&3)
	__SELECTOR_RC__=$?
	unset __JUST_RUN_DEFAULT__
	if [ "${__SELECTOR_RC__}" = "0" ] && [ -n "$WM_CMD" ]
	then
		__WM_CMD_USER_DEFAULT__="${XDG_CONFIG_HOME:-${HOME}/.config}/wayland-session-default-cmd"
		mkdir -p "$(dirname "${__WM_CMD_USER_DEFAULT__}")"
		echo "$WM_CMD" > "${__WM_CMD_USER_DEFAULT__}"
		echo "Chosen: $WM_CMD"
	else
		echo "Compositor was not selected" >&2
		# error messages should be here
		echo "${WM_CMD:-Empty result}" >&2
		exit ${__SELECTOR_RC__}
	fi
	unset __SELECTOR_RC__
	unset __WM_CMD_USER_DEFAULT__
fi

## Rough processing of wm command line
# get executable name ($0)
WM=$(printf '%s' "$WM_CMD" | xargs sh -c 'echo "$1"' arg_snip)
# get the rest of arguments
# cut executable name from beginning
WM_ARGS="${WM_CMD#"${WM}"}"
# trim spaces
WM_ARGS="${WM_ARGS%"${WM_ARGS##*[![:space:]]}"}"
WM_ARGS="${WM_ARGS#"${WM_ARGS%%[![:space:]]*}"}"
#"
# replace dashes with underscores for function names
WM_FNAME=$(echo "$WM" | tr '.-' '__' | tr -s '_')

## Sanity checks
CHECKOUT=true

if ! echo "$MODE" | grep -qE "^(${SUPPORTED_MODES})\$"
then
	echo "Mode $MODE not supported, choose $SUPPORTED_MODES" >&2
	CHECKOUT=false
fi

if ! echo "$WM" | grep -qE "^[a-zA-Z0-9_-]+$"
then
	echo "Got malformed compositor name: $WM" >&2
	CHECKOUT=false
fi

if ! [ -x "$(which "$WM")" ]
then
	echo "$WM is not an executable binary" >&2
	CHECKOUT=false
fi

if ! echo "$WM" | grep -qE "^(${SUPPORTED_WMS})$"
then
	echo "Compositor $WM not supported, choose $SUPPORTED_WMS" >&2
	CHECKOUT=false
fi

if [ -z "$XDG_RUNTIME_DIR" ]
then
	echo "\$XDG_RUNTIME_DIR is not set, something is wrong with your environment" >&2
	CHECKOUT=false
fi

# exit/return with error on failed checks
if [ "$CHECKOUT" = "false" ]
then
	exit 1

elif [ "$MODE" = "check" ]
then
	# exit successfully after supported compositors check
	echo "Checked for compositor ${WM}"
	exit 0
fi

# functions for operating on lists of variable names
filter_varnames(){
	# leave only vars with valid names, some shells or tools can inject illegal chars, i.e. env-modules
	for __VAR__ in $(cat)
	do
		if echo "${__VAR__}" | grep -qE '^[a-zA-Z_][a-zA-Z0-9_]*$'
		then
			echo ${__VAR__}
		else
			echo "Encountered illegal var name ${__VAR__}, check your shell environment" >&2
		fi
	done
}

normalize_varnames_space() {
	# pipe var names to get sorted, uniqued, normalized space-separated output
	tr ' \t\n' '\n\n\n' | tr -s '\n' | sort -u | tr '\n' ' ' | sed 's/^ \+\| \+$//g'
}

normalize_varnames_newline() {
	# pipe var names to get sorted, uniqued, normalized newline-separated output
	tr ' \t\n' '\n\n\n' | tr -s '\n' | sort -u
}

varnames_subtract() {
	# pipe in list 1, get list 2 on args, output diff newline-separated output (comm)
	__LIST1_PATH__=$(mktemp "${XDG_RUNTIME_DIR}/${WM}_list_1_XXXXXXXX")
	__LIST2_PATH__=$(mktemp "${XDG_RUNTIME_DIR}/${WM}_list_1_XXXXXXXX")
	normalize_varnames_newline > "${__LIST1_PATH__}"
	echo $* | normalize_varnames_newline > "${__LIST2_PATH__}"
	comm -23 "${__LIST1_PATH__}" "${__LIST2_PATH__}"
	rm -f "${__LIST1_PATH__}" "${__LIST2_PATH__}"
	unset __LIST1_PATH__ __LIST2_PATH__
}

varnames_intersect() {
	# pipe in list 1, get list 2 on args, output intersection newline-separated output (comm)
	__LIST1_PATH__=$(mktemp "${XDG_RUNTIME_DIR}/${WM}_list_1_XXXXXXXX")
	__LIST2_PATH__=$(mktemp "${XDG_RUNTIME_DIR}/${WM}_list_1_XXXXXXXX")
	normalize_varnames_newline > "${__LIST1_PATH__}"
	echo $* | normalize_varnames_newline > "${__LIST2_PATH__}"
	comm -12 "${__LIST1_PATH__}" "${__LIST2_PATH__}"
	rm -f "${__LIST1_PATH__}" "${__LIST2_PATH__}"
	unset __LIST1_PATH__ __LIST2_PATH__
}

varnames_union() {
	# pipe in list 1, get list 2 on args, output merged newline-separated output
	{
		normalize_varnames_newline
		echo $* | normalize_varnames_newline
	} | sort -u
}

update_unit() {
	# takes content on stdin, stages it,
	# copies to desitnation ${XDG_RUNTIME_DIR}/systemd/user/$1 if differs
	# subdirs created automatically
	__RC__=0
	__STAGED_PATH__=$(mktemp "${XDG_RUNTIME_DIR}/uwsm_staged_content_XXXXXXXX")
	cat > "${__STAGED_PATH__}"
	if [ ! -f "${XDG_RUNTIME_DIR}/systemd/user/$1" ] || [ "$(md5sum < "${__STAGED_PATH__}")" != "$(md5sum < "${XDG_RUNTIME_DIR}/systemd/user/$1")" ]
	then
		# create subdir if needed
		[ "$(dirname "$1")" != "." ] && \
		  [ ! -d "${XDG_RUNTIME_DIR}/systemd/user/$(dirname "$1")" ] && \
		  mkdir -pv "${XDG_RUNTIME_DIR}/systemd/user/$(dirname "$1")"
		# put content in place
		cp -av "${__STAGED_PATH__}" "${XDG_RUNTIME_DIR}/systemd/user/$1"
		__RC__=$?
		rm "${__STAGED_PATH__}"
		UNITS_UPDATED=true
	else
		rm "${__STAGED_PATH__}"
	fi
	unset __STAGED_PATH__
	return ${__RC__}
}

generate_units() {
	# places customized targets bound to systemd special graphical targets
	# in runtime systemd hierarchy
	if [ "${UWSM_USE_SESSION_SLICE:-false}" = "true" ]
	then
		WAYLAND_WM_SLICE=session.slice
	else
		WAYLAND_WM_SLICE=app.slice
	fi
	UNITS_UPDATED=false
	mkdir -vp "${XDG_RUNTIME_DIR}/systemd/user/"
	update_unit "wayland-session-pre@.target" <<- EOF
		# injected by ${WS_SELF}, do not edit
		[Unit]
		Description=Preparation for session of %I Wayland Window Manager
		Documentation=man:systemd.special(7)
		Requires=basic.target
		StopWhenUnneeded=yes
		BindsTo=graphical-session-pre.target
		Before=graphical-session-pre.target
	EOF
	update_unit "wayland-session@.target" <<- EOF
		# injected by ${WS_SELF}, do not edit
		[Unit]
		Description=Session of %I Wayland Window Manager
		Documentation=man:systemd.special(7)
		Requires=wayland-session-pre@%i.target
		After=wayland-session-pre@%i.target
		StopWhenUnneeded=yes
		BindsTo=graphical-session.target
		Before=graphical-session.target
	EOF
	update_unit "wayland-session-xdg-autostart@.target" <<- EOF
		# injected by ${WS_SELF}, do not edit
		[Unit]
		Description=XDG Autostart for session of %I Wayland Window Manager
		Documentation=man:systemd.special(7)
		Requires=wayland-session@%i.target
		After=wayland-session@%i.target
		StopWhenUnneeded=yes
		BindsTo=xdg-desktop-autostart.target
		Before=xdg-desktop-autostart.target
	EOF
	update_unit "wayland-wm-env@.service" <<- EOF
		# injected by ${WS_SELF}, do not edit
		[Unit]
		Description=Environment preloader for %I Wayland Window Manager
		Documentation=man:systemd.service(7)
		BindsTo=wayland-session-pre@%i.target
		Before=wayland-session-pre@%i.target
		StopWhenUnneeded=yes
		[Service]
		Type=oneshot
		RemainAfterExit=yes
		ExecStart=${WS_SELF_FULL} "%I" prepare-env
		ExecStop=${WS_SELF_FULL} "%I" cleanup-env
		Restart=no
		Slice=${WAYLAND_WM_SLICE}
	EOF
	update_unit "wayland-wm@.service" <<- EOF
		# injected by ${WS_SELF}, do not edit
		[Unit]
		Description=%I Wayland Window Manager
		Documentation=man:systemd.service(7)
		BindsTo=wayland-session@%i.target
		Before=wayland-session@%i.target
		Requires=wayland-session-pre@%i.target
		After=wayland-session-pre@%i.target
		Requires=wayland-wm-env@%i.service
		After=wayland-wm-env@%i.service
		Wants=wayland-session-xdg-autostart@%i.target
		Before=wayland-session-xdg-autostart@%i.target
		# second hand Requires= between targets is not enough to stop this in time
		PropagatesStopTo=xdg-desktop-autostart.target
		[Service]
		# awaits for 'systemd-notify --ready' from WM child
		Type=notify
		NotifyAccess=all
		ExecStart=%I
		Restart=no
		TimeoutStartSec=10
		TimeoutStopSec=10
		Slice=${WAYLAND_WM_SLICE}
	EOF
	update_unit "app-@autostart.service.d/stop-tweak.conf" <<- EOF
		# injected by ${WS_SELF}, do not edit
		[Unit]
		# make autostart apps stoppable by target
		StopPropagatedFrom=xdg-desktop-autostart.target
	EOF

	# args from plugins
	WM_ARGS_PREPEND=''
	WM_ARGS_APPEND=''
	if type "inject_args_${WM_FNAME}" >/dev/null
	then
		"inject_args_${WM_FNAME}"
	fi

	# argument treatment
	if [ -n "$WM_ARGS_PREPEND" ] || [ -n "$WM_ARGS" ] || [ -n "$WM_ARGS_APPEND" ]
	then
		update_unit "wayland-wm@${WM}.service.d/args.conf" <<- EOF
			[Service]
			ExecStart=
			ExecStart=${WM}${WM_ARGS_PREPEND:+ }${WM_ARGS_PREPEND} ${WM_ARGS}${WM_ARGS_APPEND:+ }${WM_ARGS_APPEND}
		EOF
	elif [ -f "${XDG_RUNTIME_DIR}/systemd/user/wayland-wm@${WM}.service.d/args.conf" ]
	then
		remove_unit "wayland-wm@${WM}.service.d/args.conf"
	fi

	# units from plugins
	if type "generate_units_${WM_FNAME}" >/dev/null
	then
		"generate_units_${WM_FNAME}"
	fi

	if [ "$UNITS_UPDATED" = "true" ]
	then
		echo Reloading systemd user manager
		systemctl --user daemon-reload
	else
		echo All units are up to date, reload is not needed
	fi
	unset UNITS_UPDATED
}

remove_unit(){
	# removes ${XDG_RUNTIME_DIR}/systemd/user/$1
	# removes subdir if empty
	__RC__=0
	if [ -f "${XDG_RUNTIME_DIR}/systemd/user/$1" ]
	then
		rm -v "${XDG_RUNTIME_DIR}/systemd/user/$1"
		__RC__=$?
		UNITS_UPDATED=true
		# auto remove subdir if empty
		[ "$(dirname "$1")" != "." ] && \
		  [ -z "$(ls -A "${XDG_RUNTIME_DIR}/systemd/user/$(dirname "$1")")" ] && \
		  rmdir -v "${XDG_RUNTIME_DIR}/systemd/user/$(dirname "$1")"
		#"
	elif [ -d "${XDG_RUNTIME_DIR}/systemd/user/$1" ]
	then
		rmdir "${XDG_RUNTIME_DIR}/systemd/user/$1"
		__RC__=$?
	else
		echo "${XDG_RUNTIME_DIR}/systemd/user/$1 is already gone"
	fi
	return ${__RC__}
}

remove_units() {
	# removes units from runtime hierarchy
	UNITS_UPDATED=false
	# units from plugins
	if type "remove_units_${WM_FNAME}" >/dev/null
	then
		"remove_units_${WM_FNAME}"
	fi
	for __UNIT__ in \
	  "wayland-wm-env@.service" \
	  "wayland-session-pre@.target" \
	  "wayland-session@.target" \
	  "wayland-session-xdg-autostart@.target" \
	  "wayland-wm@.service" \
	  "app-@autostart.service.d/stop-tweak.conf" \
	  "wayland-wm@${WM}.service.d/args.conf"
	do
		remove_unit "${__UNIT__}"
	done

	if [ "$UNITS_UPDATED" = "true" ]
	then
		echo Reloading systemd user manager
		systemctl --user daemon-reload
	else
		echo Units already removed, reload is not needed
	fi
	unset UNITS_UPDATED
}

get_vt() {
	# echoes current vt
	if fgconsole
	then
		return 0
	else
		echo "Could not get current VT" >&2
		return 1
	fi
}

get_session_by_vt() {
	# takes VT number, echoes session ID bound to it
	__VT__="$1"
	if [ -n "${__VT__}" ]
	then
		for __SESSION__ in $(loginctl list-sessions --no-legend | sed 's/^[[:space:]]*//; s/[[:space:]].*$//')
		do
			if \
			  [ "$(loginctl show-session ${__SESSION__} --property Name --value)" = "${USER}" ] \
			  && \
			  [ "$(loginctl show-session ${__SESSION__} --property VTNr --value)" = "${__VT__}" ]
			then
				echo ${__SESSION__}
				return 0
			else
				continue
			fi
		done
		echo "Could not find session for VT ${__VT__}" >&2
		return 1
	else
		echo "get_session_by_vt requires VT number" >&2
		return 1
	fi
}

load_config_env() {
	#### iterate config dirs in increasing importance and source additional env from relative path in $1
	__ALL_XDG_CONFIG_DIRS_REV__=''
	__CONFIG_DIR__=''
	OIFS="$IFS"
	IFS=":"
	for __CONFIG_DIR__ in ${XDG_CONFIG_HOME}:${XDG_CONFIG_DIRS}
	do
		IFS="$OIFS"
		# fill list in reverse order
		if [ -n "${__CONFIG_DIR__}" ]
		then
			__ALL_XDG_CONFIG_DIRS_REV__="${__ALL_XDG_CONFIG_DIRS_REV__}${__ALL_XDG_CONFIG_DIRS_REV__:+:}${__CONFIG_DIR__}"
		fi
	done
	IFS=":"
	for __CONFIG_DIR__ in ${__ALL_XDG_CONFIG_DIRS_REV__}
	do
		IFS="$OIFS"
		if [ -r "${__CONFIG_DIR__}/${1}" ]
		then
			echo "Loading environment from ${__CONFIG_DIR__}/${1}"
			#set -a
			. "${__CONFIG_DIR__}/${1}"
			#set +a
		fi
	done
	IFS="$OIFS"
	unset __CONFIG_DIR__
	unset __ALL_XDG_CONFIG_DIRS_REV__
	return 0
}

load_common_env() {
	load_config_env "wayland-session-env"
}

load_wm_env() {
	load_config_env "wayland-session-${WM}-env"
}

prepare_env() {
	# hopefully smartly prepares the environment and updates systemd user manager
	# has no failure processing yet
	__ENV_NAMES__=''
	__SYSTEMD_ENV_NAMES__=''
	__ENV_NAMES_AFTER__=''
	__ENV_NAMES_FOR_EXPORT__=''
	__ENV_NAMES_FOR_UNSET__=''
	__ENV_NAMES_FOR_CLEANUP__=''
	__HAS_VARS__=''

	# get current shell env names
	__ENV_NAMES__=$(
		env -0 | cut -z -d '=' -f 1 | sort -z | tr '\0' ' ' | filter_varnames | normalize_varnames_space
	)

	# get systemd user manager env names
	__SYSTEMD_ENV_NAMES__=$(
		systemctl --user show-environment | cut -d '=' -f 1 | normalize_varnames_space
	)

	# take full snapshot of env vars state (zero-delimited)
	# this will be used for comparisons later
	env -0 | sort -z > "${XDG_RUNTIME_DIR}/${WM}_initial_combined_env"

	# collect env names
	__ENV_NAMES__=$(
		env -0 | cut -z -d '=' -f 1 | sort -z | tr '\0' ' ' | filter_varnames | normalize_varnames_space
	)

	# deal with vt and session vars
	if [ -z "${XDG_VTNR}" ]
	then
		XDG_VTNR=$(get_vt) && {
			echo "Guessed XDG_VTNR=$XDG_VTNR"
			export XDG_VTNR
		}
	fi
	if [ -n "${XDG_VTNR}" ] && [ -z "${XDG_SESSION_ID}" ]
	then
		XDG_SESSION_ID=$(get_session_by_vt $XDG_VTNR) && {
			echo "Guessed XDG_SESSION_ID=$XDG_SESSION_ID"
			export XDG_SESSION_ID
		}
	fi

	#### Basic environment
	[ -f /etc/profile ] && . /etc/profile
	[ -f "${HOME}/.profile" ] && . "${HOME}/.profile"
	export PATH
	export XDG_CONFIG_DIRS="${XDG_CONFIG_DIRS:-/etc/xdg}"
	export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-${HOME}/.config}"
	export XDG_DATA_DIRS="${XDG_DATA_DIRS:-/usr/local/share:/usr/share}"
	export XDG_DATA_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}"
	export XDG_CACHE_HOME="${XDG_CACHE_HOME:-${HOME}/.cache}"
	export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/$(id -u)}"

	export XDG_CURRENT_DESKTOP="${WM}"
	export XDG_SESSION_DESKTOP="${WM}"
	export XDG_MENU_PREFIX="${WM}-"

	#### apply quirks
	if type "quirks_${WM_FNAME}" >/dev/null
	then
		echo "Applying quirks for ${WM}"
		"quirks_${WM_FNAME}" || return $?
	fi

	load_common_env || return $?

	if type "load_wm_env_${WM_FNAME}" >/dev/null
	then
		echo "WM-specific environment loading"
		"load_wm_env_${WM_FNAME}" || return $?
	else
		load_wm_env || return $?
	fi

	# hardcode unset conflicting vars.
	# if they were in systemd user manager environment,
	# they will be automatically unset by the algorithm later
	unset DISPLAY WAYLAND_DISPLAY

	# take another zero-delimited snapshot of environment for comparison
	env -0 | sort -z > "${XDG_RUNTIME_DIR}/${WM}_final_env"

	# collect env names
	__ENV_NAMES_AFTER__=$(
		env -0 | cut -z -d '=' -f 1 | sort -z | tr '\0' ' ' | filter_varnames | normalize_varnames_space
	)

	# finalize export vars:
	__ENV_NAMES_FOR_EXPORT__=$(
		{
			# names of vars modified since initial combined environment
			comm -z -13 \
			  "${XDG_RUNTIME_DIR}/${WM}_initial_combined_env" \
			  "${XDG_RUNTIME_DIR}/${WM}_final_env" \
			| cut -z -d '=' -f 1 \
			| tr '\0' '\n' \
			| filter_varnames

			# add defined subset of ${ALWAYS_EXPORT_VARS}
			echo ${ALWAYS_EXPORT_VARS} \
			| normalize_varnames_space \
			| varnames_intersect ${__ENV_NAMES_AFTER__} \
			| normalize_varnames_newline
			# exclude ${NEVER_EXPORT_VARS}
		} | varnames_subtract ${NEVER_EXPORT_VARS} | normalize_varnames_space
	)

	# finalize unset vars:
	# env vars that were in intial combined environment, but were explicitly unset since
	__ENV_NAMES_FOR_UNSET__=$(
		echo ${__ENV_NAMES__} \
		| varnames_subtract ${__ENV_NAMES_AFTER__} \
		| normalize_varnames_space
	)

	# generate list of vars for cleanup after exit
	__ENV_NAMES_FOR_CLEANUP__=$(
		{
			# names of env vars not yet present in systemd user manager, but going to
			echo ${__ENV_NAMES_FOR_EXPORT__} \
			  | varnames_subtract ${__SYSTEMD_ENV_NAMES__}
			# also add ${ALWAYS_CLEANUP_VARS}
			echo ${ALWAYS_CLEANUP_VARS}
			# then subtract ${NEVER_CLEANUP_VARS}
		} | normalize_varnames_space \
		  | varnames_subtract ${NEVER_CLEANUP_VARS} \
		  | normalize_varnames_space
	)

	# cleanup temp files
	rm -f \
	  "${XDG_RUNTIME_DIR}/${WM}_initial_combined_env" \
	  "${XDG_RUNTIME_DIR}/${WM}_final_env"

	# save cleanup list
	echo ${__ENV_NAMES_FOR_CLEANUP__} \
	  | normalize_varnames_newline \
	  > "${XDG_RUNTIME_DIR}/${WM}_for_cleanup_env_names"

	__HAS_VARS__=false
	echo "Exporting vars to systemd user manager:"
	for VAR in ${__ENV_NAMES_FOR_EXPORT__}
	do
		__HAS_VARS__=true
		echo "  $VAR"
	done

	if [ "${__HAS_VARS__}" = "true" ]
	then
		if systemctl --user import-environment ${__ENV_NAMES_FOR_EXPORT__}
		then
			true
		else
			echo "Could not export environment to systemd user session" >&2
			exit 1
		fi
	else
		echo "  No vars"
	fi

	__HAS_VARS__=false
	echo "Unsetting vars from systemd user manager:"
	for VAR in ${__ENV_NAMES_FOR_UNSET__}
	do
		__HAS_VARS__=true
		echo "  $VAR"
	done

	if [ "${__HAS_VARS__}" = "true" ]
	then
		systemctl --user unset-environment ${__ENV_NAMES_FOR_UNSET__}
	else
		echo "  No vars"
	fi

	__HAS_VARS__=false
	echo "Vars to be cleaned up from systemd user manager after exit:"
	for VAR in ${__ENV_NAMES_FOR_CLEANUP__}
	do
		__HAS_VARS__=true
		echo "  $VAR"
	done
	if [ "${__HAS_VARS__}" = "true" ]
	then
		true
	else
		echo "  No vars"
	fi
}

cleanup_vars() {
	# take var names from "${XDG_RUNTIME_DIR}/${WM}_for_cleanup_env_names"
	# and ${ALWAYS_CLEANUP_VARS}
	# exclude ${NEVER_CLEANUP_VARS}
	# and remove them from systemd user manager
	__CLEANUP_RC__=''
	__VAR__=''
	__HAS_VARS__=''
	__ENV_NAMES_FOR_CLEANUP__=$(
		{
			# saved cleanup list if exists
			[ -f "${XDG_RUNTIME_DIR}/${WM}_for_cleanup_env_names" ] \
			  && cat "${XDG_RUNTIME_DIR}/${WM}_for_cleanup_env_names"
			# vars to always cleanup
			echo ${ALWAYS_CLEANUP_VARS}
			# subtract vars to never cleanup
		} | varnames_subtract ${NEVER_CLEANUP_VARS} | normalize_varnames_space
	)
	echo "Cleaning up variables:"
	__HAS_VARS__=false
	for __VAR__ in ${__ENV_NAMES_FOR_CLEANUP__}
	do
		__HAS_VARS__=true
		echo "  ${__VAR__}"
	done
	if [ "${__HAS_VARS__}" = "true" ]
	then
		systemctl --user unset-environment ${__ENV_NAMES_FOR_CLEANUP__}
		__CLEANUP_RC__=$?
	else
		echo "  No vars"
		__CLEANUP_RC__=0
	fi
	[ -f "${XDG_RUNTIME_DIR}/${WM}_for_cleanup_env_names" ] \
	  && rm "${XDG_RUNTIME_DIR}/${WM}_for_cleanup_env_names"
	return ${__CLEANUP_RC__}
}

trap_exit() {
	if systemctl --user is-active -q wayland-wm@${WM}.service
	then
		systemctl --user stop wayland-wm@${WM}.service
	fi
}

#### More mode decisions

if [ "$MODE" = "cleanup-env" ]
then
	cleanup_vars
	__CLEANUP_RC__=$?
	exit ${__CLEANUP_RC__}

elif [ "$MODE" = "unitgen" ]
then
	generate_units
	exit

elif [ "$MODE" = "unitrm" ]
then
	if systemctl --user is-active -q 'wayland-wm@*.service'
	then
		echo "wayland-wm@*.service is already running:" >&2
		systemctl --user list-units --state=active --no-legend wayland-wm@*.service >&2
		echo 'Will not remove units' >&2
		exit 1
	else
		remove_units
		exit
	fi

elif [ "$MODE" = "prepare-env" ]
then
	# for use by wayland-wm-env@.service
	# this mode prepares environment, exports it to systemd user manager
	# no failure processing yet
	prepare_env

elif [ "$MODE" = "start" ]
then
	# all in one go systemd start, supports sourcing from login shell
	# start if no WM is running
	if systemctl --user is-active -q 'wayland-wm@*.service'
	then
		echo "wayland-wm@*.service is already running:"
		systemctl --user list-units --state=active --no-legend wayland-wm@*.service
		exit 0
	else
		if ! systemctl is-active -q graphical.target
		then
			cat <<- EOM
			System is not at graphical.target. It might be a good idea to screen for this with:
			
			  if systemctl is-active -q graphical.target ; then ...
			
			Will continue in 3 seconds...
			EOM
			sleep 3
		fi
		generate_units
		# makeshift reverse of --wait to bind ccompositor's life to session
		# HUP is received when logind terminates session
		trap trap_exit INT TERM HUP EXIT
		echo "starting ${WM}..."
		systemctl --user start --wait wayland-wm@${WM}.service &
		wait
		exit
	fi

elif [ "$MODE" = "stop" ]
then
	if systemctl --user is-active -q wayland-wm@${WM}.service
	then
		systemctl --user stop wayland-wm@${WM}.service
	else
		echo "wayland-wm@${WM}.service is not running"
		exit 0
	fi
fi
