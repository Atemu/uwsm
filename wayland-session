#!/bin/sh

# Universal Wayland Desktop Session Manager
# Runs selected WM with plugin-extendable tweaks
# Manages systemd environment and targets along the way
# Inspired by and uses some techniques from:
#  https://github.com/xdbob/sway-services
#  https://github.com/alebastr/sway-systemd
#  https://github.com/swaywm/sway
#  https://people.debian.org/~mpitt/systemd.conf-2016-graphical-session.pdf

#### definitions

__SUPPORTED_MODES__='check|unitgen|prepare-env|start|stop|cleanup-env|unitrm'
__PLUGIN_PREFIX_PATHS__="${UWSM_PLUGIN_PREFIX_PATHS:-/lib:/usr/lib:/usr/local/lib:${HOME}/.local/lib}"
__PLUGIN_DIR_NAME__="${UWSM_PLUGIN_DIR_NAME:-wayland-session-plugins}"

# variables that will always be exported to systemd user manager during startup
UWSM_VARS_ALWAYS_EXPORT="XDG_SESSION_ID
XDG_VTNR
XDG_CURRENT_DESKTOP
XDG_SESSION_DESKTOP
XDG_MENU_PREFIX
PATH"

# variables that will never be exported to systemd user manager during startup
UWSM_VARS_NEVER_EXPORT="PWD
LS_COLORS
INVOCATION_ID
SHLVL
SHELL"

# variables that will always be cleaned up from systemd user manager during shutdown
UWSM_VARS_ALWAYS_CLEANUP="DISPLAY
WAYLAND_DISPLAY
XDG_SESSION_ID
XDG_VTNR
XDG_CURRENT_DESKTOP
XDG_SESSION_DESKTOP
XDG_MENU_PREFIX
PATH
XCURSOR_THEME
XCURSOR_SIZE
LANG"

# variables that will never be cleaned up from systemd user manager during shutdown
UWSM_VARS_NEVER_CLEANUP="SSH_AGENT_LAUNCHER
SSH_AUTH_SOCK
SSH_AGENT_PID"

#### Functions

self_naming() {
	__WS_SELF__="$(basename "$0")"
	# wayland-wm-env@.service needs full path in case wayland-session is in ${USER}/.local/bin
	# which most likely is not in PATH of systemd user manager when wayland-wm-env@.service starts
	__WS_SELF_FULL__="$(which "${__WS_SELF__}" 2>/dev/null)"
}

show_help() {
	self_naming
	cat <<- EOF
		
		Universal Wayland Session Manager with systemd integration.
		
		Usage:
		  Managing WM:
		    ${__WS_SELF__} ${__SUPPORTED_MODES__} wm|"wm --with args"
		    ${__WS_SELF__} stop
		  Helpers for use from within WM session:
		    ${__WS_SELF__} finalize [ADDITIONAL] [VARS]
		    ${__WS_SELF__} app ...
		    ${__WS_SELF__} background ...
		    ${__WS_SELF__} session ...
		  Checkers:
		    ${__WS_SELF__} is-active [vm]
		    ${__WS_SELF__} may-start [-v] [VTNR] [VTNR]...
		
		Managing WM:
		
		  Basic modes:
		
		    check:        checks supported arguments
		    start:        does all unit preparations and starts WM via a service
		                  with --wait and a set of traps to bind to its life
		    stop:         stops WM. If no WM argument given, stops by wildcard
		
		  If more control needed, more grained modes available:
		
		    unitgen:      generates systemd unit files in runtime hierarchy
		    prepare-env:  prepares environment for WM in systemd user manager
		                  (for use in ExecStart of wayland-wm-env@.service)
		    cleanup-env:  cleans up environment from systemd user manager
		                  (for use in ExecStop of wayland-wm-env@.service)
		    unitrm:       removes systemd unit files from runtime hierarchy
		
		  WM command:
		
		    Any compositor executable or a full command line with arguments,
		    that is compatible with systemd service "Exec=" field.
		
		    Special values "select" and "default" will bring selection menu to choose
		    from desktop entries located in "wayland-sessions" dirs in XDG data
		    hierarchy, or launch previous selection right away.
		    Selection is saved in "wayland-session-default-cmd" file in the config
		    hierarchy.
		
		WM should be configured to run this on startup:
		
		  ${__WS_SELF__} finalize [[VAR] ANOTHER_VAR]
		
		    This exports WAYLAND_DISPLAY and DISPLAY to systemd and dbus environments
		    and notifies systemd that WM has finished startup.
		    Without this startup will fail in 10 seconds.
		    Any addional vars that WM sets that should be accessible to apps should be
		    given as arguments, they will be exported too.
		    Think of things like SWAYSOCK in sway.
		
		During startup at stage of "graphical-session-pre.target" environment is
		sourced from shell profile and from files "wayland-session-env" and
		"wayland-session-${wm}-env" in XDG config hierarchy
		(in order of increasing importance). Delta will be exported to systemd and
		dbus activation environments, and cleaned up when services are stopped.
		
		It is highly recommended to configure your WM to launch apps explicitly scoped
		in special user session slices (app.slice, background.slice, session.slice).
		See "man systemd.special", "man systemd-run"
		
		${__WS_SELF__} provides custom nested slices for apps to live in and be
		terminated on session end:
		
		  app-graphical.slice
		  background-graphical.slice
		  session-graphical.slice
		
		And helper commands to handle all the systemd-run invocations for you:
		
		  ${__WS_SELF__} app your_app [with --args]
		  ${__WS_SELF__} background your_app [with --args]
		  ${__WS_SELF__} session your_app [with --args]
		
		If app launching is configured as recommended, you can put WM itself in
		session.slice (as recommended by man systemd.special) by setting:
		
		    UWSM_USE_SESSION_SLICE=true
		
		This var affects unitgen phase, Slice= parameter of WM services.
		(best to export it in shell profile).
		
		Checkers:
		
		  ${__WS_SELF__} is-active [wm]
		
		    Checks whether any/specific wayland session is running (RC 0) or not (RC 1)
		
		  ${__WS_SELF__} may-start [-v] [VTNR] [VTNR]...
		
		    Checks whether it is OK to launch a wayland session (RC 0) or not (RC 1)
		    Conditions:
		      Running from login shell
		      No wayland session is running
		      Foreground VT is among allowed (default: 1)
		    Arguments:
		        -v: list dealbreakers
		      VTNR: allowed VT numbers to override default 1
		
		See code comments for documentation on plugins.
	EOF
}

wm_selector() {
	# parse desktop entries of wayland-sessions, present choice via whiptail
	python - <<- EOF
		try:
		    import os, sys, shlex
		    from xdg.DesktopEntry import DesktopEntry
		except ModuleNotFoundError as E:
		    print(E, file=sys.stderr)
		    sys.exit(126)
		
		def which(executable):
		    'Simple which'
		    for path in os.getenv('PATH', '').split(os.path.pathsep):
		        path = os.path.join(path, executable)
		        if os.path.exists(path) and os.access(path, os.X_OK):
		            return path
		    return ''
		
		def get_default_cmd():
		    'Gets WM command line from wayland-session-default-cmd file in config hierarchy'
		    for dir in [
		            os.getenv('XDG_CONFIG_HOME', os.path.join(os.getenv('HOME'), '.config')),
		            *(os.getenv('XDG_DATA_DIRS', '/etc/xdg').split(':'))
		        ]:
		        cmd_cache_file = os.path.join(dir, 'wayland-session-default-cmd')
		        if os.path.exists(cmd_cache_file):
		            try:
		                with open(cmd_cache_file, 'r') as opened_cmd_cache_file:
		                    for line in opened_cmd_cache_file.readlines():
		                        if line.strip():
		                            return line.strip()
		            except exception as E:
		                print(E, file=sys.stderr)
		                sys.exit(126)
		    return ''
		
		default = get_default_cmd()
		seen_entries = []
		entry_files = []
		choices = []
		
		# find relevant desktop entries as first found paths in data hierarchy
		for dir in [
		        os.getenv('XDG_DATA_HOME', os.path.join(os.getenv('HOME'), '.local/share')),
		        *(os.getenv('XDG_DATA_DIRS', '/usr/local/share:/usr/share').split(':'))
		    ]:
		    dir = os.path.join(dir, 'wayland-sessions')
		    if os.path.isdir(dir):
		        try:
		            os.chdir(dir)
		            for file in os.listdir():
		                if os.path.splitext(file)[1] == '.desktop' and file not in seen_entries:
		                    seen_entries.append(file)
		                    entry_files.append(os.path.join(dir, file))
		        except Exception as E:
		            print(E, file=sys.stderr)
		            sys.exit(126)
		
		# fill choces list with [Exec, Name], filtered
		for entry in entry_files:
		    try:
		        entry = DesktopEntry(entry)
		    except:
		        # just skip unparsable entry
		        continue
		    # skip inaccessible executables or hidden entries
		    if (
		        entry.getHidden()
		        or entry.getNoDisplay()
		        or (entry.getTryExec() and not entry.findTryExec())
		        or not entry.getExec()
		        or not which(shlex.split(entry.getExec())[0])
		    ):
		        continue
		    items = [entry.getExec(), entry.getName() or os.path.splitext(os.path.basename(entry.filename))[0]]
		    choices.extend(items)
		
		if len(choices) == 2 and default == choices[0]:
		    # just spit out the only preselected choice
		    print(choices[0], file=sys.stderr)
		    sys.exit(0)
		elif len(choices) > 2 and len(choices) % 2 == 0:
		    # drop default if not among choices
		    if default and default not in choices[::2]:
		        default = ''
		    elif default and os.getenv('__JUST_RUN_DEFAULT__', 'false') == 'true':
		        # just spit out default
		        for choice in choices[::2]:
		            if choice == default:
		                print(choice, file=sys.stderr)
		                sys.exit(0)
		elif len(choices) == 0:
		    print('No choices found', file=sys.stderr)
		    sys.exit(126)
		else:
		    print('Malformed choices', file=sys.stderr)
		    sys.exit(126)
		
		# generate arguments for whiptail exec
		argv = (
		    'whiptail',
		    'whiptail',
		    '--clear',
		    '--backtitle',
		    'Universal Wayland Session Manager',
		    '--title',
		    'Choose compositor',
		    '--nocancel',
		    *(
		        ('--default-item', default) if default else ()
		    ),
		    '--menu',
		    '',
		    '0',
		    '0',
		    '0',
		    '--notags',
		    *(choices)
		)
		
		# replace whiptail theme with simple default colors
		whiptail_env = dict(os.environ)
		whiptail_env.update({
		    'TERM': 'linux',
		    'NEWT_COLORS': ';'.join([
		        'root=default,default',
		        'border=default,default',
		        'window=default,default',
		        'shadow=default,default',
		        'title=black,lightgray',
		        'button=default,default',
		        'actbutton=black,lightgray',
		        'compactbutton=default,default',
		        'checkbox=default,default',
		        'actcheckbox=black,lightgray',
		        'entry=default,default',
		        'disentry=default,default',
		        'label=default,default',
		        'listbox=default,default',
		        'actlistbox=black,lightgray',
		        'sellistbox=black,lightgray',
		        'actsellistbox=black,lightgray',
		        'textbox=default,default',
		        'acttextbox=black,lightgray',
		        'emptyscale=default,default',
		        'fullscale=default,default',
		        'helpline=default,default',
		        'roottext=default,default'
		    ])
		})
		
		try:
		    os.execlpe(*argv, whiptail_env)
		except Exception as E:
		    print(E, file=sys.stderr)
		    sys.exit(126)
	EOF
}

#### functions for operating on lists of variable names

varnames_filter(){
	# leave only vars with valid names, some shells or tools can inject illegal chars, i.e. env-modules
	for __VAR__ in $(cat)
	do
		if echo "${__VAR__}" | grep -qE '^[a-zA-Z_][a-zA-Z0-9_]*$'
		then
			echo ${__VAR__}
		else
			echo "Encountered illegal var name ${__VAR__}, check your shell environment" >&2
		fi
	done
}

varnames_normalize_space() {
	# pipe var names to get sorted, uniqued, normalized space-separated output
	tr ' \t\n' '\n\n\n' | tr -s '\n' | sort -u | tr '\n' ' ' | sed 's/^ \+\| \+$//g'
}

varnames_normalize_newline() {
	# pipe var names to get sorted, uniqued, normalized newline-separated output
	tr ' \t\n' '\n\n\n' | tr -s '\n' | sort -u
}

varnames_subtract() {
	# pipe in list 1, get list 2 on args, output diff newline-separated output (comm)
	__LIST1_PATH__=$(mktemp "${XDG_RUNTIME_DIR}/${__WM__}_list_1_XXXXXXXX")
	__LIST2_PATH__=$(mktemp "${XDG_RUNTIME_DIR}/${__WM__}_list_1_XXXXXXXX")
	varnames_normalize_newline > "${__LIST1_PATH__}"
	echo $* | varnames_normalize_newline > "${__LIST2_PATH__}"
	comm -23 "${__LIST1_PATH__}" "${__LIST2_PATH__}"
	rm -f "${__LIST1_PATH__}" "${__LIST2_PATH__}"
	unset __LIST1_PATH__ __LIST2_PATH__
}

varnames_intersect() {
	# pipe in list 1, get list 2 on args, output intersection newline-separated output (comm)
	__LIST1_PATH__=$(mktemp "${XDG_RUNTIME_DIR}/${__WM__}_list_1_XXXXXXXX")
	__LIST2_PATH__=$(mktemp "${XDG_RUNTIME_DIR}/${__WM__}_list_1_XXXXXXXX")
	varnames_normalize_newline > "${__LIST1_PATH__}"
	echo $* | varnames_normalize_newline > "${__LIST2_PATH__}"
	comm -12 "${__LIST1_PATH__}" "${__LIST2_PATH__}"
	rm -f "${__LIST1_PATH__}" "${__LIST2_PATH__}"
	unset __LIST1_PATH__ __LIST2_PATH__
}

varnames_union() {
	# pipe in list 1, get list 2 on args, output merged newline-separated output
	{
		varnames_normalize_newline
		echo $* | varnames_normalize_newline
	} | sort -u
}

varnames_defined() {
	# pipe in var names, print only defined ones
	for __VAR__ in $(cat)
	do
		# get "DEFINED" if defined, empty otherwise
		__EVAL__=$(eval printf %s "\${${__VAR__}+DEFINED}")
		if [ "${__EVAL__}" = "DEFINED" ]
		then
			echo "$VAR"
		fi
	done
	unset __VAR__ __EVAL__
}

#### functions for manipulating units

update_unit() {
	# takes content on stdin, stages it,
	# copies to desitnation ${XDG_RUNTIME_DIR}/systemd/user/$1 if differs
	# subdirs created automatically
	__RC__=0
	__STAGED_PATH__=$(mktemp "${XDG_RUNTIME_DIR}/uwsm_staged_content_XXXXXXXX")
	cat > "${__STAGED_PATH__}"
	if [ ! -f "${XDG_RUNTIME_DIR}/systemd/user/$1" ] || [ "$(md5sum < "${__STAGED_PATH__}")" != "$(md5sum < "${XDG_RUNTIME_DIR}/systemd/user/$1")" ]
	then
		# create subdir if needed
		[ "$(dirname "$1")" != "." ] && \
		  [ ! -d "${XDG_RUNTIME_DIR}/systemd/user/$(dirname "$1")" ] && \
		  mkdir -pv "${XDG_RUNTIME_DIR}/systemd/user/$(dirname "$1")"
		# put content in place
		cp -av "${__STAGED_PATH__}" "${XDG_RUNTIME_DIR}/systemd/user/$1"
		__RC__=$?
		rm "${__STAGED_PATH__}"
		UNITS_UPDATED=true
	else
		rm "${__STAGED_PATH__}"
	fi
	unset __STAGED_PATH__
	return ${__RC__}
}

generate_units() {
	# places customized targets bound to systemd special graphical targets
	# in runtime systemd hierarchy

	self_naming

	[ -n "${__WS_SELF_FULL__}" ] || {
		echo "${__WS_SELF__} is not in PATH" >&2
		exit 1
	}

	if [ "${UWSM_USE_SESSION_SLICE:-false}" = "true" ]
	then
		WAYLAND_WM_SLICE=session.slice
	else
		WAYLAND_WM_SLICE=app.slice
	fi
	UNITS_UPDATED=false
	mkdir -vp "${XDG_RUNTIME_DIR}/systemd/user/"

	# targets
	update_unit "wayland-session-pre@.target" <<- EOF
		# injected by ${__WS_SELF__}, do not edit
		[Unit]
		Description=Preparation for session of %I Wayland Window Manager
		Documentation=man:systemd.special(7)
		Requires=basic.target
		StopWhenUnneeded=yes
		BindsTo=graphical-session-pre.target
		Before=graphical-session-pre.target
		PropagatesStopTo=graphical-session-pre.target
	EOF
	update_unit "wayland-session@.target" <<- EOF
		# injected by ${__WS_SELF__}, do not edit
		[Unit]
		Description=Session of %I Wayland Window Manager
		Documentation=man:systemd.special(7)
		Requires=wayland-session-pre@%i.target graphical-session-pre.target
		After=wayland-session-pre@%i.target graphical-session-pre.target
		StopWhenUnneeded=yes
		BindsTo=graphical-session.target
		Before=graphical-session.target
		PropagatesStopTo=graphical-session.target
	EOF
	update_unit "wayland-session-xdg-autostart@.target" <<- EOF
		# injected by ${__WS_SELF__}, do not edit
		[Unit]
		Description=XDG Autostart for session of %I Wayland Window Manager
		Documentation=man:systemd.special(7)
		Requires=wayland-session@%i.target graphical-session.target
		After=wayland-session@%i.target graphical-session.target
		StopWhenUnneeded=yes
		BindsTo=xdg-desktop-autostart.target
		Before=xdg-desktop-autostart.target
		PropagatesStopTo=xdg-desktop-autostart.target
	EOF

	# services
	update_unit "wayland-wm-env@.service" <<- EOF
		# injected by ${__WS_SELF__}, do not edit
		[Unit]
		Description=Environment preloader for %I Wayland Window Manager
		Documentation=man:systemd.service(7)
		BindsTo=wayland-session-pre@%i.target
		Before=wayland-session-pre@%i.target
		StopWhenUnneeded=yes
		[Service]
		Type=oneshot
		RemainAfterExit=yes
		ExecStart=${__WS_SELF_FULL__} prepare-env "%I"
		ExecStop=${__WS_SELF_FULL__} cleanup-env "%I"
		Restart=no
		Slice=${WAYLAND_WM_SLICE}
	EOF
	update_unit "wayland-wm@.service" <<- EOF
		# injected by ${__WS_SELF__}, do not edit
		[Unit]
		Description=%I Wayland Window Manager
		Documentation=man:systemd.service(7)
		BindsTo=wayland-session@%i.target
		Before=wayland-session@%i.target
		Requires=wayland-wm-env@%i.service graphical-session-pre.target
		After=wayland-wm-env@%i.service graphical-session-pre.target
		Wants=wayland-session-xdg-autostart@%i.target xdg-desktop-autostart.target
		Before=wayland-session-xdg-autostart@%i.target xdg-desktop-autostart.target app-graphical.slice background-graphical.slice session-graphical.slice
		PropagatesStopTo=app-graphical.slice background-graphical.slice session-graphical.slice
		[Service]
		# awaits for 'systemd-notify --ready' from WM child
		Type=notify
		NotifyAccess=all
		ExecStart=%I
		Restart=no
		TimeoutStartSec=10
		TimeoutStopSec=10
		Slice=${WAYLAND_WM_SLICE}
	EOF

	# slices
	update_unit "app-graphical.slice" <<- EOF
		# injected by ${__WS_SELF__}, do not edit
		[Unit]
		Description=User Graphical Application Slice
		Documentation=man:systemd.special(7)
		PartOf=graphical-session.target
		After=graphical-session.target
	EOF
	update_unit "background-graphical.slice" <<- EOF
		# injected by ${__WS_SELF__}, do not edit
		[Unit]
		Description=User Graphical Background Application Slice
		Documentation=man:systemd.special(7)
		PartOf=graphical-session.target
		After=graphical-session.target
	EOF
	update_unit "session-graphical.slice" <<- EOF
		# injected by ${__WS_SELF__}, do not edit
		[Unit]
		Description=User Graphical Session Application Slice
		Documentation=man:systemd.special(7)
		PartOf=graphical-session.target
		After=graphical-session.target
	EOF

	# tweaks
	update_unit "app-@autostart.service.d/slice-tweak.conf" <<- EOF
		# injected by ${__WS_SELF__}, do not edit
		[Unit]
		# make autostart apps stoppable by target
		#StopPropagatedFrom=xdg-desktop-autostart.target
		PartOf=xdg-desktop-autostart.target
		[Service]
		# also put them in special graphical app slice
		Slice=app-graphical.slice
	EOF
	# this does not work
	#update_unit "xdg-desktop-portal-gtk.service.d/part-tweak.conf" <<- EOF
	#	# injected by ${__WS_SELF__}, do not edit
	#	[Unit]
	#	# make the same thing as -wlr portal to stop correctly
	#	PartOf=graphical-session.target
	#	After=graphical-session.target
	#	ConditionEnvironment=WAYLAND_DISPLAY
	#EOF
	update_unit "xdg-desktop-portal-.service.d/slice-tweak.conf" <<- EOF
		# injected by ${__WS_SELF__}, do not edit
		[Service]
		# make xdg-desktop-portal-*.service implementations part of graphical scope
		Slice=app-graphical.slice
	EOF

	# args from plugins
	__WM_ARGS_PREPEND__=''
	__WM_ARGS_APPEND__=''
	if type "inject_args_${__WM_FNAME__}" >/dev/null
	then
		"inject_args_${__WM_FNAME__}"
	fi

	# argument treatment
	if [ -n "${__WM_ARGS_PREPEND__}" ] || [ -n "${__WM_ARGS__}" ] || [ -n "${__WM_ARGS_APPEND__}" ]
	then
		update_unit "wayland-wm@${__WM__}.service.d/args.conf" <<- EOF
			[Service]
			ExecStart=
			ExecStart=${__WM__}${__WM_ARGS_PREPEND__:+ }${__WM_ARGS_PREPEND__}${__WM_ARGS__:+ }${__WM_ARGS__}${__WM_ARGS_APPEND__:+ }${__WM_ARGS_APPEND__}
		EOF
	elif [ -f "${XDG_RUNTIME_DIR}/systemd/user/wayland-wm@${__WM__}.service.d/args.conf" ]
	then
		remove_unit "wayland-wm@${__WM__}.service.d/args.conf"
	fi

	# units from plugins
	if type "generate_units_${__WM_FNAME__}" >/dev/null
	then
		"generate_units_${__WM_FNAME__}"
	fi

	if [ "$UNITS_UPDATED" = "true" ]
	then
		echo Reloading systemd user manager
		systemctl --user daemon-reload
	else
		echo All units are up to date, reload is not needed
	fi
	unset UNITS_UPDATED
}

remove_unit(){
	# removes ${XDG_RUNTIME_DIR}/systemd/user/$1
	# removes subdir if empty
	__RC__=0
	if [ -f "${XDG_RUNTIME_DIR}/systemd/user/$1" ]
	then
		rm -v "${XDG_RUNTIME_DIR}/systemd/user/$1"
		__RC__=$?
		UNITS_UPDATED=true
		# auto remove subdir if empty
		[ "$(dirname "$1")" != "." ] && \
		  [ -z "$(ls -A "${XDG_RUNTIME_DIR}/systemd/user/$(dirname "$1")")" ] && \
		  rmdir -v "${XDG_RUNTIME_DIR}/systemd/user/$(dirname "$1")"
		#"
	elif [ -d "${XDG_RUNTIME_DIR}/systemd/user/$1" ]
	then
		rmdir "${XDG_RUNTIME_DIR}/systemd/user/$1"
		__RC__=$?
	else
		echo "${XDG_RUNTIME_DIR}/systemd/user/$1 is already gone"
	fi
	return ${__RC__}
}

remove_units() {
	# removes units from runtime hierarchy
	UNITS_UPDATED=false
	# units from plugins
	if type "remove_units_${__WM_FNAME__}" >/dev/null
	then
		"remove_units_${__WM_FNAME__}"
	fi

	remove_unit "wayland-session-pre@.target"
	remove_unit "wayland-session@.target"
	remove_unit "wayland-session-xdg-autostart@.target"
	remove_unit "wayland-wm-env@.service"
	remove_unit "wayland-wm@.service"
	remove_unit "wayland-wm@${__WM__}.service.d/args.conf"
	remove_unit "app-graphical.slice"
	remove_unit "background-graphical.slice"
	remove_unit "session-graphical.slice"
	remove_unit "app-@autostart.service.d/slice-tweak.conf"
	#remove_unit "xdg-desktop-portal-gtk.service.d/part-tweak.conf"
	remove_unit "xdg-desktop-portal-.service.d/slice-tweak.conf"

	if [ "$UNITS_UPDATED" = "true" ]
	then
		echo Reloading systemd user manager
		systemctl --user daemon-reload
	else
		echo Units already removed, reload is not needed
	fi
	unset UNITS_UPDATED
}

#### functions for dealing with VTs, sessions and ENV

get_vt() {
	# echoes current vt
	if fgconsole
	then
		return 0
	else
		echo "Could not get current VT" >&2
		return 1
	fi
}

get_session_by_vt() {
	# takes VT number, echoes session ID bound to it
	__VT__="$1"
	if [ -n "${__VT__}" ]
	then
		for __SESSION__ in $(loginctl list-sessions --no-legend | sed 's/^[[:space:]]*//; s/[[:space:]].*$//')
		do
			if \
			  [ "$(loginctl show-session ${__SESSION__} --property Name --value)" = "${USER}" ] \
			  && \
			  [ "$(loginctl show-session ${__SESSION__} --property VTNr --value)" = "${__VT__}" ]
			then
				echo ${__SESSION__}
				return 0
			else
				continue
			fi
		done
		echo "Could not find session for VT ${__VT__}" >&2
		return 1
	else
		echo "get_session_by_vt requires VT number" >&2
		return 1
	fi
}

load_config_env() {
	#### iterate config dirs in increasing importance and source additional env from relative path in $1
	__ALL_XDG_CONFIG_DIRS_REV__=''
	__CONFIG_DIR__=''
	OIFS="$IFS"
	IFS=":"
	for __CONFIG_DIR__ in ${XDG_CONFIG_HOME}:${XDG_CONFIG_DIRS}
	do
		IFS="$OIFS"
		# fill list in reverse order
		if [ -n "${__CONFIG_DIR__}" ]
		then
			__ALL_XDG_CONFIG_DIRS_REV__="${__ALL_XDG_CONFIG_DIRS_REV__}${__ALL_XDG_CONFIG_DIRS_REV__:+:}${__CONFIG_DIR__}"
		fi
	done
	IFS=":"
	for __CONFIG_DIR__ in ${__ALL_XDG_CONFIG_DIRS_REV__}
	do
		IFS="$OIFS"
		if [ -r "${__CONFIG_DIR__}/${1}" ]
		then
			echo "Loading environment from ${__CONFIG_DIR__}/${1}"
			#set -a
			. "${__CONFIG_DIR__}/${1}"
			#set +a
		fi
	done
	IFS="$OIFS"
	unset __CONFIG_DIR__
	unset __ALL_XDG_CONFIG_DIRS_REV__
	return 0
}

load_common_env() {
	load_config_env "wayland-session-env"
}

load_wm_env() {
	load_config_env "wayland-session-${__WM__}-env"
}

prepare_env() {
	# hopefully smartly prepares the environment and updates systemd user manager
	# has no failure processing yet
	__ENV_NAMES__=''
	__SYSTEMD_ENV_NAMES__=''
	__ENV_NAMES_AFTER__=''
	__ENV_NAMES_FOR_EXPORT__=''
	__ENV_NAMES_FOR_UNSET__=''
	__ENV_NAMES_FOR_CLEANUP__=''
	__HAS_VARS__=''

	# get current shell env names
	__ENV_NAMES__=$(
		env -0 | cut -z -d '=' -f 1 | sort -z | tr '\0' ' ' | varnames_filter | varnames_normalize_space
	)

	# get systemd user manager env names
	__SYSTEMD_ENV_NAMES__=$(
		systemctl --user show-environment | cut -d '=' -f 1 | varnames_normalize_space
	)

	# take full snapshot of env vars state (zero-delimited)
	# this will be used for comparisons later
	env -0 | sort -z > "${XDG_RUNTIME_DIR}/${__WM__}_env_initial_combined"

	# collect env names
	__ENV_NAMES__=$(
		env -0 | cut -z -d '=' -f 1 | sort -z | tr '\0' ' ' | varnames_filter | varnames_normalize_space
	)

	# deal with vt and session vars
	if [ -z "${XDG_VTNR}" ]
	then
		XDG_VTNR=$(get_vt) && {
			echo "Guessed XDG_VTNR=$XDG_VTNR"
			export XDG_VTNR
		}
	fi
	if [ -n "${XDG_VTNR}" ] && [ -z "${XDG_SESSION_ID}" ]
	then
		XDG_SESSION_ID=$(get_session_by_vt $XDG_VTNR) && {
			echo "Guessed XDG_SESSION_ID=$XDG_SESSION_ID"
			export XDG_SESSION_ID
		}
	fi

	#### Basic environment
	[ -f /etc/profile ] && . /etc/profile
	[ -f "${HOME}/.profile" ] && . "${HOME}/.profile"
	export PATH
	export XDG_CONFIG_DIRS="${XDG_CONFIG_DIRS:-/etc/xdg}"
	export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-${HOME}/.config}"
	export XDG_DATA_DIRS="${XDG_DATA_DIRS:-/usr/local/share:/usr/share}"
	export XDG_DATA_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}"
	export XDG_CACHE_HOME="${XDG_CACHE_HOME:-${HOME}/.cache}"
	export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/$(id -u)}"

	export XDG_CURRENT_DESKTOP="${__WM__}"
	export XDG_SESSION_DESKTOP="${__WM__}"
	export XDG_MENU_PREFIX="${__WM__}-"

	#### apply quirks
	if type "quirks_${__WM_FNAME__}" >/dev/null
	then
		echo "Applying quirks for ${__WM__}"
		"quirks_${__WM_FNAME__}" || return $?
	fi

	load_common_env || return $?

	if type "load_wm_env_${__WM_FNAME__}" >/dev/null
	then
		echo "WM-specific environment loading"
		"load_wm_env_${__WM_FNAME__}" || return $?
	else
		load_wm_env || return $?
	fi

	# hardcode unset conflicting vars.
	# if they were in systemd user manager environment,
	# they will be automatically unset by the algorithm later
	unset DISPLAY WAYLAND_DISPLAY

	# take another zero-delimited snapshot of environment for comparison
	env -0 | sort -z > "${XDG_RUNTIME_DIR}/${__WM__}_env_final"

	# collect env names
	__ENV_NAMES_AFTER__=$(
		env -0 | cut -z -d '=' -f 1 | sort -z | tr '\0' ' ' | varnames_filter | varnames_normalize_space
	)

	# finalize export vars:
	__ENV_NAMES_FOR_EXPORT__=$(
		{
			# names of vars modified since initial combined environment
			comm -z -13 \
			  "${XDG_RUNTIME_DIR}/${__WM__}_env_initial_combined" \
			  "${XDG_RUNTIME_DIR}/${__WM__}_env_final" \
			| cut -z -d '=' -f 1 \
			| tr '\0' '\n' \
			| varnames_filter

			# add defined subset of ${UWSM_VARS_ALWAYS_EXPORT}
			echo ${UWSM_VARS_ALWAYS_EXPORT} \
			| varnames_normalize_space \
			| varnames_intersect ${__ENV_NAMES_AFTER__} \
			| varnames_normalize_newline
			# exclude ${UWSM_VARS_NEVER_EXPORT}
		} | varnames_subtract ${UWSM_VARS_NEVER_EXPORT} | varnames_normalize_space
	)

	# finalize unset vars:
	# env vars that were in intial combined environment, but were explicitly unset since
	__ENV_NAMES_FOR_UNSET__=$(
		echo ${__ENV_NAMES__} \
		| varnames_subtract ${__ENV_NAMES_AFTER__} \
		| varnames_normalize_space
	)

	# generate list of vars for cleanup after exit
	__ENV_NAMES_FOR_CLEANUP__=$(
		{
			# names of env vars not yet present in systemd user manager, but going to
			echo ${__ENV_NAMES_FOR_EXPORT__} \
			  | varnames_subtract ${__SYSTEMD_ENV_NAMES__}
			# also add ${UWSM_VARS_ALWAYS_CLEANUP}
			echo ${UWSM_VARS_ALWAYS_CLEANUP}
			# then subtract ${UWSM_VARS_NEVER_CLEANUP}
		} | varnames_normalize_space \
		  | varnames_subtract ${UWSM_VARS_NEVER_CLEANUP} \
		  | varnames_normalize_space
	)

	# cleanup temp files
	rm -f \
	  "${XDG_RUNTIME_DIR}/${__WM__}_env_initial_combined" \
	  "${XDG_RUNTIME_DIR}/${__WM__}_env_final"

	# save cleanup list
	echo ${__ENV_NAMES_FOR_CLEANUP__} \
	  | varnames_normalize_newline \
	  > "${XDG_RUNTIME_DIR}/${__WM__}_env_names_for_cleanup"

	__HAS_VARS__=false
	echo "Exporting vars to systemd user manager:"
	for VAR in ${__ENV_NAMES_FOR_EXPORT__}
	do
		__HAS_VARS__=true
		echo "  $VAR"
	done

	if [ "${__HAS_VARS__}" = "true" ]
	then
		if systemctl --user import-environment ${__ENV_NAMES_FOR_EXPORT__}
		then
			true
		else
			echo "Could not export environment to systemd user session" >&2
			exit 1
		fi
	else
		echo "  No vars"
	fi

	__HAS_VARS__=false
	echo "Unsetting vars from systemd user manager:"
	for VAR in ${__ENV_NAMES_FOR_UNSET__}
	do
		__HAS_VARS__=true
		echo "  $VAR"
	done

	if [ "${__HAS_VARS__}" = "true" ]
	then
		systemctl --user unset-environment ${__ENV_NAMES_FOR_UNSET__}
	else
		echo "  No vars"
	fi

	__HAS_VARS__=false
	echo "Vars to be cleaned up from systemd user manager after exit:"
	for VAR in ${__ENV_NAMES_FOR_CLEANUP__}
	do
		__HAS_VARS__=true
		echo "  $VAR"
	done
	if [ "${__HAS_VARS__}" = "true" ]
	then
		true
	else
		echo "  No vars"
	fi
}

cleanup_env() {
	# take var names from "${XDG_RUNTIME_DIR}/${__WM__}_env_names_for_cleanup"
	# and ${UWSM_VARS_ALWAYS_CLEANUP}
	# exclude ${UWSM_VARS_NEVER_CLEANUP}
	# and remove them from systemd user manager
	__CLEANUP_RC__=''
	__VAR__=''
	__HAS_VARS__=''
	__ENV_NAMES_FOR_CLEANUP__=$(
		{
			# saved cleanup list if exists
			[ -f "${XDG_RUNTIME_DIR}/${__WM__}_env_names_for_cleanup" ] \
			  && cat "${XDG_RUNTIME_DIR}/${__WM__}_env_names_for_cleanup"
			# vars to always cleanup
			echo ${UWSM_VARS_ALWAYS_CLEANUP}
			# subtract vars to never cleanup
		} | varnames_subtract ${UWSM_VARS_NEVER_CLEANUP} | varnames_normalize_space
	)
	echo "Cleaning up variables:"
	__HAS_VARS__=false
	for __VAR__ in ${__ENV_NAMES_FOR_CLEANUP__}
	do
		__HAS_VARS__=true
		echo "  ${__VAR__}"
	done
	if [ "${__HAS_VARS__}" = "true" ]
	then
		systemctl --user unset-environment ${__ENV_NAMES_FOR_CLEANUP__}
		__CLEANUP_RC__=$?
	else
		echo "  No vars"
		__CLEANUP_RC__=0
	fi
	[ -f "${XDG_RUNTIME_DIR}/${__WM__}_env_names_for_cleanup" ] \
	  && rm "${XDG_RUNTIME_DIR}/${__WM__}_env_names_for_cleanup"
	return ${__CLEANUP_RC__}
}

is_active() {
	# check and list active wayland wm unit
	# return 0 if active, 1 if not
	if [ -n "$1" ]
	then
		# specific
		CHECK_UNIT="wayland-wm@$(printf '%s' "${1}" | xargs sh -c 'printf "%s" "$1"' arg_snip).service"
	else
		# generic
		CHECK_UNIT="wayland-wm@*.service"
	fi
	if systemctl --user -q is-active "${CHECK_UNIT}"
	then
		systemctl list-units --user --state=active --quiet --full --plain "${CHECK_UNIT}"
		return 0
	else
		systemctl list-units --user --all --quiet --full --plain "${CHECK_UNIT}"
		return 1
	fi
}

trap_exit() {
	if systemctl --user is-active -q wayland-wm@${__WM__}.service
	then
		systemctl --user stop wayland-wm@${__WM__}.service
	fi
}

#### End of functions

#### Non-WM argument actions and helpers

if [ "$#" = "0" ] || case "$*" in --help|--help\ *|*\ --help|*\ --help\ *|-h|*\ -h|-h\ *|*\ -h\ *) true ;; *) false ;; esac
then
	show_help
	exit 0

elif [ "$1" = "app" ] || [ "$1" = "background" ] || [ "$1" = "session" ]
then
	# for use inside WM
	# exec argv scoped into selected slice
	RAND=$(tr -cd '0-9a-f' < /dev/urandom | head -c 10) || exit 1
	#SLICE="${1}-graphical"
	SLICE="${1}"
	PREFIX="${SLICE}-$(systemd-escape "${XDG_SESSION_DESKTOP}")" || exit 1
	shift
	APP_NAME="$(systemd-escape "$1")" || exit 1
	exec systemd-run --user --scope --slice "${SLICE}.slice" -u "${PREFIX}-${APP_NAME}-${RAND}.scope" -qG "$@"

elif [ "$1" = "is-active" ]
then
	shift
	is_active "$@"
	exit $?

elif [ "$1" = "may-start" ]
then
	# check if in login shell, system is at graphical.target, no WM is running[, in requested VTs]
	shift
	if [ "$1" = "-v" ]
	then
		VERBOSE=true
		shift
	else
		VERBOSE=false
	fi
	MAY_START=true
	ARGS_FINE=true
	for CHECK_VT in ${*:-1}
	do
		case "$CHECK_VT" in
			[1-9]|1[0-2]) true ;;
			*)
				echo "\"$CHECK_VT\" is not a number for F-key VT" >&2
				ARGS_FINE=false
			;;
		esac
	done
	[ "$ARGS_FINE" = "true" ] || exit 1
	PARENT_SHELL_CMD="$(head -zn1 < "/proc/${PPID}/cmdline")"
	[ "${PARENT_SHELL_CMD}" != "${PARENT_SHELL_CMD#-}" ] || {
		[ "$VERBOSE" = "true" ] && echo "Parent process $PARENT_SHELL_CMD is not a login shell"
		MAY_START=false
	}
	systemctl is-active -q graphical.target || {
		[ "$VERBOSE" = "true" ] && echo "System is not at graphical.target"
		MAY_START=false
	}
	VT=$(fgconsole)
	[ -n "$VT" ] || {
		[ "$VERBOSE" = "true" ] && echo "Not on VT"
		MAY_START=false
	}
	! is_active >/dev/null || {
		[ "$VERBOSE" = "true" ] && echo "Wayland session is already running"
		MAY_START=false
	}
	VT_MATCHED=false
	for CHECK_VT in ${*:-1}
	do
		[ "$VT" = "$CHECK_VT" ] && VT_MATCHED=true && break
	done
	[ "$VT_MATCHED" = "true" ] || {
		[ "$VERBOSE" = "true" ] && echo "VT $VT is not among requested (${*:-1})"
		MAY_START=false
	}
	[ "$MAY_START" = "true" ]
	exit $?

elif [ "$1" = "finalize" ]
then
	# for use inside WM
	# export vars and report readiness
	shift
	if [ -z "$WAYLAND_DISPLAY" ]
	then
		echo "WAYLAND_DISPLAY is not defined. Are we being run by a wayland compositor or not?" >&2
		exit 1
	fi
	__VARS__=$(echo WAYLAND_DISPLAY DISPLAY $* | varnames_filter | varnames_defined | varnames_normalize_space)
	dbus-update-activation-environment --systemd ${__VARS__} && \
	  systemctl --user import-environment ${__VARS__} && \
	  exec systemd-notify --ready
	echo "Something went wrong" >&2
	exit 1

elif [ "$1" = "stop" ] && [ "$#" = "1" ]
then
	# generic fast stop
	if systemctl --user is-active -q 'wayland-wm@*.service'
	then
		systemctl --user stop 'wayland-wm@*.service'
	else
		echo "wayland-wm@*.service is not running"
		exit 0
	fi

#### WM actions

# env modes failsafe
elif { [ "$1" = "prepare-env" ] || [ "$1" = "cleanup-env" ] ; } && \
     { [ -z "$MANAGERPID" ] || [ "$MANAGERPID" != "$PPID" ] ; }
then
	echo "$1 can only be executed by systemd user manager as a service" >&2
	exit 1

elif echo "$1" | grep -qE "${__SUPPORTED_MODES__}" && [ -n "$2" ] && [ "$#" = "2" ]
then
	# scoop mode and wm cmd
	__MODE__="${1}"
	__WM_CMD__="${2}"
else
	echo "Wrong arguments!" >&2
	show_help >&2
	exit 1
fi

if [ "${__WM_CMD__}" = "select" ] || [ "${__WM_CMD__}" = "default" ]
then
	[ "${__WM_CMD__}" = "select" ] && export __JUST_RUN_DEFAULT__=false
	[ "${__WM_CMD__}" = "default" ] && export __JUST_RUN_DEFAULT__=true
	__WM_CMD__=$(wm_selector 3>&1 1>&2 2>&3)
	__SELECTOR_RC__=$?
	unset __JUST_RUN_DEFAULT__
	if [ "${__SELECTOR_RC__}" = "0" ] && [ -n "${__WM_CMD__}" ]
	then
		__WM_CMD_USER_DEFAULT__="${XDG_CONFIG_HOME:-${HOME}/.config}/wayland-session-default-cmd"
		mkdir -p "$(dirname "${__WM_CMD_USER_DEFAULT__}")"
		echo "${__WM_CMD__}" > "${__WM_CMD_USER_DEFAULT__}"
		echo "Chosen: ${__WM_CMD__}"
	else
		echo "Compositor was not selected" >&2
		# error messages should be here
		echo "${__WM_CMD__:-Empty result}" >&2
		exit ${__SELECTOR_RC__}
	fi
	unset __SELECTOR_RC__
	unset __WM_CMD_USER_DEFAULT__
fi

#### Rough processing of wm command line

# get executable name ($0)
__WM__=$(printf '%s' "${__WM_CMD__}" | xargs sh -c 'printf "%s" "$1"' arg_snip)

# get the rest of arguments
# cut executable name from beginning
__WM_ARGS__="${__WM_CMD__#"${__WM__}"}"

# trim spaces
__WM_ARGS__="${__WM_ARGS__%"${__WM_ARGS__##*[![:space:]]}"}"
__WM_ARGS__="${__WM_ARGS__#"${__WM_ARGS__%%[![:space:]]*}"}"
#"

# replace dashes with underscores for function names
__WM_FNAME__=$(echo "${__WM__}" | tr '.-' '__' | tr -s '_')

#### Sanity checks

CHECKOUT=true

if ! echo "${__WM__}" | grep -qE "^[a-zA-Z0-9_.-]+$"
then
	echo "Got malformed compositor name:" >&2
	echo "${__WM__}" >&2
	CHECKOUT=false
fi

if ! [ -x "$(which "${__WM__}")" ]
then
	echo "${__WM__} is not an executable" >&2
	CHECKOUT=false
fi

if [ -z "$XDG_RUNTIME_DIR" ]
then
	echo "\$XDG_RUNTIME_DIR is not set, something is wrong with your environment" >&2
	CHECKOUT=false
fi

# exit/return with error on failed checks
if [ "$CHECKOUT" = "false" ]
then
	exit 1

elif [ "${__MODE__}" = "check" ]
then
	# exit successfully after basic compositors check
	echo "Checked for compositor ${__WM__}"
	exit 0
fi

#### Load WM plugin

# Plugins should be named ${__WM__}.sh.in
# Plugins should only contain specifically named functions.
# Function name suffix is expected to be WM executable name with
# all dashes and dots replaced by underscores and underscores singled
# $(echo "${__WM__}" | tr '.-' '__' | tr -s '_')
# example:
#
#  #!/bin/false
#
#  # function to make arbitrary actions before loading wayland-session-${__WM__}-env
#  quirks_my_cool_wm() {
#    # here additional vars can be added set for session manager
#    # like
#    UWSM_VARS_ALWAYS_EXPORT="${UWSM_VARS_ALWAYS_EXPORT} SOME OTHER VARS"
#    UWSM_VARS_NEVER_EXPORT="${UWSM_VARS_ALWAYS_EXPORT} SOME OTHER VARS"
#    UWSM_VARS_ALWAYS_CLEANUP"${UWSM_VARS_ALWAYS_CLEANUP} SOME OTHER VARS"
#    UWSM_VARS_NEVER_CLEANUP"${UWSM_VARS_ALWAYS_CLEANUP} SOME OTHER VARS"
#    # or export more vars for session
#    export I_WANT_THIS_IN_SESSION=yes
#    # or prepare a config for WM
#    # or set a var to modify what sourcing wayland-session-env, wayland-session-${__WM__}-env
#    # in the next stage will do
#    ...
#  }
#
#  load_wm_env_my_cool_wm() {
#    # custom mechanism for loading of env (or a stub)
#    # completely replaces loading from wayland-session-${__WM__}-env in config dirs
#    # so repeat it
#    load_wm_env
#    # and add ours
#    load_config_env "${__WM__}/env"
#  }
#
#  generate_units_my_cool_wm() {
#    # place some units or fragments specifically for my-cool-wm
#    # use update_unit function
#    # reloading is handled by main script
#  }
#
#  remove_units_my_cool_wm() {
#    # remove the same units
#    # use remove_unit function
#    # reloading is handled by main script
#  }
#
#  # function to add/replace args for WM command
#  inject_args_my_cool_wm() {
#    # prepend some args before original args
#    __WM_ARGS_PREPEND__='-s --logmsg="foo bar"'
#    # on second thought, drop original args
#    __WM_ARGS__=''
#    # and append a bunch more
#    __WM_ARGS_APPEND__='--lifetime 1h'
#    my-cool-wm-communicate exit
#  }

OIFS="$IFS"
IFS=":"
for __PLUGIN_PREFIX_PATH__ in ${__PLUGIN_PREFIX_PATHS__}
do
	IFS="$OIFS"
	if [ -n "$__PLUGIN_PREFIX_PATH__" ] && \
	   [ -n "$__PLUGIN_DIR_NAME__" ] && \
	   [ -f "${__PLUGIN_PREFIX_PATH__}/${__PLUGIN_DIR_NAME__}/${__WM__}.sh.in" ]
	then
		echo "Loading plugin: ${__PLUGIN_PREFIX_PATH__}/${__PLUGIN_DIR_NAME__}/${__WM__}.sh.in"
		. "${__PLUGIN_PREFIX_PATH__}/${__PLUGIN_DIR_NAME__}/${__WM__}.sh.in"
	fi
done
unset __PLUGIN_PREFIX_PATH__ __PLUGIN_PREFIX_PATHS__ __PLUGIN_DIR_NAME__

#### More mode decisions

if [ "${__MODE__}" = "prepare-env" ]
then
	# for use by wayland-wm-env@.service
	# this mode prepares environment, exports it to systemd user manager
	# no failure processing yet
	prepare_env
	exit

elif [ "${__MODE__}" = "cleanup-env" ]
then
	# for use by wayland-wm-env@.service
	# this mode cleans up systemd user manager environment from vars stored in
	# "${XDG_RUNTIME_DIR}/${__WM__}_env_names_for_cleanup"
	# no failure processing yet
	cleanup_env
	exit

elif [ "${__MODE__}" = "unitgen" ]
then
	generate_units
	exit

elif [ "${__MODE__}" = "unitrm" ]
then
	if systemctl --user is-active -q 'wayland-wm@*.service'
	then
		echo "wayland-wm@*.service is already running:" >&2
		systemctl --user list-units --state=active --no-legend wayland-wm@*.service >&2
		echo 'Will not remove units' >&2
		exit 1
	else
		remove_units
		exit
	fi

elif [ "${__MODE__}" = "start" ]
then
	# all in one go systemd start, supports sourcing from login shell
	# start if no WM is running
	if systemctl --user is-active -q 'wayland-wm@*.service'
	then
		echo "wayland-wm@*.service is already running:"
		systemctl --user list-units --state=active --no-legend wayland-wm@*.service
		exit 0
	else
		if ! systemctl is-active -q graphical.target
		then
			cat <<- EOM
			System is not at graphical.target. It might be a good idea to screen for this with:
			
			  if systemctl is-active -q graphical.target ; then ...
			
			Will continue in 3 seconds...
			EOM
			sleep 3
		fi
		generate_units
		# makeshift reverse of --wait to bind ccompositor's life to session
		# HUP is received when logind terminates session
		trap trap_exit INT TERM HUP EXIT
		echo "starting ${__WM__}..."
		systemctl --user start --wait wayland-wm@${__WM__}.service &
		wait
		exit
	fi

elif [ "${__MODE__}" = "stop" ]
then
	if systemctl --user is-active -q wayland-wm@${__WM__}.service
	then
		systemctl --user stop wayland-wm@${__WM__}.service
	else
		echo "wayland-wm@${__WM__}.service is not running"
		exit 0
	fi
fi
